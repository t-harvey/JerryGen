{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .h and the .c
    files -- look for the "body" and "header" markers }}
{{!
    Callbacks are used differently according to context; we will pass
    around a "callback" as a calling_context, which is a struct of
    two Interpreter_Type's, one for the function pointer, and the other
    for the "this" pointer; the services provided for callbacks are:

    1) initialize -- this really just calls all of the initializers
    for the types used by this callback

    2) interpreter_get_<callback>_value -- this works just like any other
    interpreter_get_*_value and returns a calling_context

    3) run_<callback>_handler -- this is the C function that will be
    run when the Javascript user invokes his callback; unlike
    most(all?) of the other _handler's, this function looks at the
    "function" Interpreter_Type (the first parameter to the handler) to
    either invoke it as a Javascript function, or grab the
    Native_Object associated with that value -- which will be a C
    function pointer -- and run that directly

    4) interpreter_create_<callback>_value -- this takes a C function
    pointer and returns a calling_context using the following
    methodology:
        1) create an empty object
	2) make it invokable (with interpreter_create_external_function())
	3) assign the C-function pointer to the Native Object of our
	   new object
	4) build a calling_context out of the object (with NULL for
    	   the "this" value, unless we have one...)
    
    
}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#header}}
{{#callbacks}}
#ifndef {{{callbackName}}}_H_
#define {{{callbackName}}}_H_
{{/callbacks}}
{{/header}}

/* these are included to simplify the generator. Remove if not needed.*/
/* #include <string> */
/* #include <vector> */
#include <stdio.h>
#include <string.h>
#include "jerryscript.h"

{{#header}}
#include "{{{utilities_filename}}}.h"
{{#callbacks}}
{{#externalTypes}}
#include "{{{package}}}/{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}
{{/callbacks}}
{{/header}}
{{#body}}
{{#callbacks}}
#include "{{{callbackName}}}.h"
{{/callbacks}}
{{/body}}

{{#callbacks}}
{{#header}}typedef calling_context {{{callbackName}}}_calling_context;
typedef {{{callbackName}}}_calling_context* {{{callbackName}}}_calling_context_Array;

/* this is the type signature of functions that can be assigned
   to a {{{callbackName}}}_calling_context */
typedef {{#return_type}}{{{C_Type}}}{{/return_type}} (* {{{callbackName}}}_callback) ({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{^finalArgument}}, {{/finalArgument}}{{/arguments}});

{{/header}}
{{/callbacks}}

{{#callbacks}}
{{#body}}
static Interpreter_Type
run_{{{callbackName}}}_function_handler(
	     const Interpreter_Type func_value, /**< function object */
	     const Interpreter_Type this_value, /**< this arg */
             const Interpreter_Type *args_p, /**< function arguments */
             const jerry_length_t args_cnt) /**< number of function arguments */
{
{{!
    ********************************************************************
    TODO: THIS CODE DOESN'T WORK IF THEY NEED interpreter_get_value_..._ARRAY !!!
    (b/c we don't create the get_..._Array function anywhere...)
    ********************************************************************  }}
    /* demarshal the arguments */
    {{#arguments}}
        {{#variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}_Array {{{name}}} = interpreter_get_array_of_{{{C_Type}}}(args_p, args_cnt, {{{paramIndex}}});
   	     {{/C_and_Jerryscript_Types}}
        {{/variadic}}
        {{^variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}} {{{name}}} = interpreter_get_{{{C_Type}}}{{#is_array}}_Array{{/is_array}}_value(args_p[{{{paramIndex}}}]{{#callback}}, this_value{{/callback}});
             {{/C_and_Jerryscript_Types}}	
        {{/variadic}}
    {{/arguments}}

{{#return_type}}
{{ ! for the "return_value", the logic is as follows: 1. don't put out
the declaration if it's a void return type or this function returns
the "this" pointer (is that possible with a callback, in WebIDL?); 2.
put out the declaration with an assignment from "run" routine }}
    {{^voidReturnType}}{{^return_is_this}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}} return_value = {{/return_is_this}}{{/voidReturnType}}run_{{{callbackName}}}_function(({{{name}}}_calling_context) {func_value, this_value}{{^arguments.length}});{{/arguments.length}}{{#arguments.length}},{{/arguments.length}}
{{#arguments}}{{{indentation}}}{{{name}}}{{{separator}}}{{/arguments}}{{#arguments.length}};{{/arguments.length}}

{{/return_type}}
    {{! if the return value is a string (or array of strings), we want
        to enter it into the Jerryscript environment _before_ we
        deallocate our local strings, as it's possible that the return
        value is just a copy of one of args }}
    {{#return_type}}
        {{#is_string}}
    {{! DOES THE FOLLOWING COVER ALL OF THE PERMUTATIONS? }}
    /* put the string into Jerryscript before we cleanup any string arguments */
    Interpreter_Type string_value = jerry_create_string{{#is_array}}_Array{{/is_array}}({{^is_array}}(const jerry_char_t *){{/is_array}}return_value);
        {{/is_string}}
    {{/return_type}}
    {{! FREE MALLOC'D STRINGS}}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	    {{^callback}}
	        {{#is_string}}
		{{^is_array}}
    if ({{{name}}} != NULL) free({{{name}}});
		{{/is_array}}
       		{{/is_string}}
    	    {{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
    {{#return_type}}
        {{#return_is_this}}
    /* return a reference back to this interface */
    return this_value;
        {{/return_is_this}}
        {{^return_is_this}}
            {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
            {{/voidReturnType}}
            {{^voidReturnType}}
                {{^is_string}}
    return interpreter_create_{{^is_array}}{{{Jerryscript_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}(return_value);
                {{/is_string}}
                {{#is_string}}
     return string_value;
                {{/is_string}}
            {{/voidReturnType}}
        {{/return_is_this}}
    {{/return_type}}
} /* run_{{{callbackName}}}_function_handler */

{{/body}}
{{/callbacks}}
{{#callbacks}}
{{! TODO: WE (CURRENTLY) IGNORE ARRAYS OF CALLBACKS!!! }}
{{{callbackName}}}_calling_context
interpreter_get_{{{callbackName}}}_value(Interpreter_Type value, Interpreter_Type this_ptr){{#header}};

{{/header}}
{{#body}}
{
    Interpreter_Type function_value = jerry_value_to_object(value);
    return ({{{callbackName}}}_calling_context) {function_value, this_ptr};
} /* interpreter_get_{{{callbackName}}}_value */

{{/body}}

/* like all the interpreter_create_* functions, this one takes a C
   variable and creates its Jerryscript/Javascript equivalent */
{{#body}}
/* callbacks are simply functions, so when we want to create a
   callback, what it means in the world of Jerryscript is that we want to
   assign the C function to some callable thing on the Javascript
   side; as usual, return a callback context, since that is our
   abstraction of Jerryscript functions */
{{/body}}
{{{callbackName}}}_calling_context interpreter_create_{{{callbackName}}}_value({{{callbackName}}}_callback x){{#header}};

{{/header}}
{{#body}}
{
    Interpreter_Type new_function = jerry_create_external_function(
                                       run_{{{callbackName}}}_function_handler);
    Interpreter_Type empty_this_value = jerry_create_undefined();

    jerry_object_native_info_t checksum = {};
    Native_Object_set(x, new_function, &checksum);

    return ({{{callbackName}}}_calling_context){new_function, empty_this_value};
} /* interpreter_create_{{{name}}}_value */
{{/body}}

{{/callbacks}}
{{#callbacks}}
{{#body}}
/* we'll use these wrapper functions to marshal the parameters for
   the function and then call the function through the interpreter */

{{/body}}
{{#return_type}}{{{C_Type}}}{{/return_type}} run_{{{callbackName}}}_function(const {{{name}}}_calling_context {{{name}}}_context{{^arguments.length}}){{#header}};{{/header}}{{/arguments.length}}{{#arguments.length}},{{/arguments.length}}
{{#arguments}}{{{indentation}}}{{#C_and_Jerryscript_Types}}{{{C_Type}}} {{{name}}}{{{separator}}}{{/C_and_Jerryscript_Types}}{{/arguments}}{{#arguments.length}}{{#header}};{{/header}}{{/arguments.length}}
{{#body}}
{
    /* check to see if the calling_context has an underlying
       C-function pointer attached to the Jerryscript object (hidden in
       the Native_Object field) */
    static jerry_object_native_info_t checksum = {};
    jerry_error_t error_value;
    {{{callbackName}}}_callback native_c_function;

    native_c_function =
    Native_Object_get({{{name}}}_context.function_value,
		      &checksum, &error_value);
    if (native_c_function != NULL)
    {
        /* if there's a valid C function, call it */
        {{^voidReturnType}}return {{/voidReturnType}}native_c_function( {{#arguments}}{{{name}}}{{^finalArgument}},{{/finalArgument}}{{/arguments}} );
    }
    else
    {
        /* if this is a function called from inside Jerryscript,
	   convert all of the passed-in parameters to Interpreter_Type's and
    	   make the call */
{{#arguments}}{{#C_and_Jerryscript_Types}}
        Interpreter_Type {{{name}}}_value = interpreter_create_{{{Jerryscript_Type}}}({{{name}}});
{{/C_and_Jerryscript_Types}}{{/arguments}}

        Interpreter_Type argv[] = { {{#arguments}}{{{name}}}_value{{^finalArgument}},{{/finalArgument}}{{/arguments}} };
        Interpreter_Type jerry_return_value =
	              jerry_call_function({{{name}}}_context.function_value,
					  {{{name}}}_context.this_value,
					  argv, {{{arguments.length}}});
	
    {{#return_type}}
    {{^voidReturnType}}
        return ({{{C_Type}}})interpreter_get_{{{C_Type}}}_value(jerry_return_value);
    {{/voidReturnType}}
    {{/return_type}}
    }
} /* run_{{{callbackName}}}_function */
{{/body}}

{{/callbacks}}
{{#callbacks}}

void initialize_{{{callbackName}}}_(void){{#header}};{{/header}}
{{#body}}
{
    /* even though we don't actually store anything for callbacks,
       we'll create a prototype object for each callback in the
       Javascript environment to ensure that we only call this
       initialization code once (this also ensures that we don't
       get into an infinite loop of initialization routines calling
       each other) */

    /* first, check to see if the prototype object exists for this
       callback; if so, just return */
    Interpreter_Type prototype = get_prototype((char *)"{{{name}}}");
    if (!jerry_value_has_error_flag(prototype) &&
        !jerry_value_is_undefined(prototype))
    {
        jerry_release_value(prototype);
	return;
    }

    /* create the prototype object */
    Interpreter_Type {{{name}}}_prototype_object = jerry_create_object();

    /* store the prototype in the global prototypes holder */
    Interpreter_Type global_object = jerry_get_global_object();
    register_prototype((char *)"{{{name}}}", {{{name}}}_prototype_object);

    jerry_release_value(global_object);
    jerry_release_value({{{name}}}_prototype_object);

    /* finally, make sure that all of the types upon which the callback
       depends have been loaded; note that if there's a cycle,
       initializing all of the included data structures _after_ we
       create this one should(?) keep us from running infinitely
       (this list could be empty: ) */
{{#externalTypes}}
    initialize_{{{type}}}_();
{{/externalTypes}}
{{#non_intrinsic_types}}
    initialize_{{{type_name}}}_();
{{/non_intrinsic_types}}

} /* initialize_{{{callbackName}}}_ */

/* we need to register the initialize_{{{callbackName}}}_ function so
   that it gets run automatically... */
__attribute__((constructor))
static void register_initialize_{{{callbackName}}}(void)
{
    /* ...supplied by webidl_utilities... */
    register_initialization_function(initialize_{{{callbackName}}}_);
{{#is_module}}
    register_require_function("{{{callbackName}}}", interpreter_get_{{{callbackName}}}_value);
{{/is_module}}
} /* register_initialize_{{{callbackName}}} */

{{/body}}
{{#debug_printing}}
void debug_print_{{{callbackName}}} (char *variable_name,
     				      {{{name}}}_calling_context value,
				      unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    /* check to see if the calling_context has an underlying
       C-function pointer attached to the Jerryscript object (hidden in
       the Native_Object field) */
    static jerry_object_native_info_t checksum = {};
    jerry_error_t error_value;
    {{{callbackName}}}_callback native_c_function;

    native_c_function =
          Native_Object_get(value.function_value,
			    &checksum, &error_value);
 
   printf("%*s%s -- CALLBACK FUNCTION (Native %s implementation)\n",
          indentation, "", variable_name,
          (native_c_function != NULL)?"C":"Javascript");
} /* debug_print_{{{callbackName}}} */
{{/body}}
{{/debug_printing}}
{{/callbacks}}

{{#header}}
{{#callbacks}}
#endif /* {{{callbackName}}}_H_ */
{{/callbacks}}
{{/header}}
{{/OBEYFORMATTING}}
