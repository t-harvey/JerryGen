{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .h and the .c
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#header}}
#ifndef {{moduleName}}_TYPES_H_
#define {{moduleName}}_TYPES_H_
{{/header}}

/* these are included to simplify the generator. Remove if not needed.*/
/* #include <string> */
/* #include <vector> */
#include <stdio.h>
#include <string.h>
#include "{{{utilities_filename}}}.h"

{{! put out includes for all of the definitions and interfaces }}
{{#allExternalTypes.length}}
/* these are required/specified by the ExternalType attribute attached
   to definitions and interfaces */
{{/allExternalTypes.length}} 
{{#allExternalTypes}}
#include "{{{package}}}/{{{package}}}_Types.h"
{{/allExternalTypes}}

{{#body}}
#include "{{moduleName}}_Types.h"
{{/body}}
{{#header}}
#include "jerryscript.h"
{{#sorted_types_list}}
{{#is_enum}} {{! ENUMS }}
typedef enum { {{#members}}{{{indentation}}}{{{name}}}{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} }{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}} {{/onlyOneMember}}{{{name}}};
{{/is_enum}}
{{#is_callback}}
#include "{{{name}}}.h"
{{/is_callback}}
{{#is_dictionary}}{{! DICTIONARIES }}
#include "{{{dictionaryName}}}.h"
{{/is_dictionary}}
{{#is_interface}}  {{! INTERFACES }}
#include "{{{interfaceName}}}.h"
{{/is_interface}}

{{/sorted_types_list}}
{{/header}}

{{#body}}
/* INITIALIZATION FUNCTION DECLARATIONS */
{{!first, make sure that any external types are initialized before
   initializing the interfaces }}
{{#allExternalTypes}}
extern void load_all_{{{package}}}_interfaces(void);
{{/allExternalTypes}}
{{#interfaces}}
extern void load_{{{name}}}_interface(void);
{{/interfaces}}
{{/body}}

{{#header}}/* MUST BE CALLED BEFORE TRYING TO USE ANYTHING DEFINED IN THIS PACKAGE! */{{/header}}
void load_all_{{{moduleName}}}_members(void){{#header}};{{/header}}
{{#body}}
{
    create_prototypes_holder();

{{#interfaces}}
    initialize_{{{interfaceName}}}_();
{{/interfaces}}
{{#dictionaries}}
    initialize_{{{dictionaryName}}}_();
{{/dictionaries}}
} /* load_all_{{{moduleName}}}_members */

{{/body}}
{{#enums.length}}
{{! enumeration types are represented in Javascript as strings, so
    getting them across to Jerryscript and back requires some
    finagling }}
static int enum_index(char *target, char **array){{#header}};{{/header}}
{{#body}}
{
    int i = 0;
    while (array[i] != '\0')
        if (!strcmp(target, array[i]))
	    return i;
    /* fallthrough indicates the string's not in the array */
    return -1;
} /* enum_index */
{{/body}}
{{/enums.length}}

{{#enums}}
{{! we follow the same naming scheme as for dictionaries... }}

{{! we first need strings that match the enumeration values }}
{{#body}}
static char *{{{name}}}_strings[] = { {{#members}}{{{indentation}}}"{{{name}}}"{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} };{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}};{{/onlyOneMember}}

{{/body}}
{{{name}}} interpreter_get_{{{name}}}_value(Interpreter_Type value){{#header}};{{/header}}
{{#body}}
{
    return ({{{name}}})enum_index(interpreter_get_string_value(value), {{{name}}}_strings);
} /* interpreter_get_{{{name}}}_value */
{{/body}}

Interpreter_Type interpreter_create_{{{name}}}({{{name}}} x){{#header}};{{/header}}
{{#body}}
{
    return interpreter_create_string ((const jerry_char_t *) "{{{name}}}");
} /* interpreter_create_{{{name}}} */
{{/body}}
{{/enums}}

{{#header}}
#endif /* {{moduleName}}_TYPES_H_ */
{{/header}}
{{/OBEYFORMATTING}}
