{{^TAG_USED_TO_FORCE_MUSTACHE_TO_OBEY_VERTICAL_WHITESPACING}}
{{! This one .mustache file is used to create both the .h and the .c
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#header}}
#ifndef {{moduleName}}_TYPES_H_
#define {{moduleName}}_TYPES_H_
{{/header}}

// these are included to simplify the generator. Remove if not needed.
//#include <string>
//#include <vector>
#include <stdio.h>

typedef char * string;

{{#body}}
#include "{{moduleName}}_Types.h"
{{/body}}
#include "jerryscript.h"

{{#header}}
/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by Jerryscript, and
   Jerryscript also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, Jerryscript
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free); getting back the Native_Object with
   Native_Object_get is straightforward, although there is little error
   checking on either get() or set(), currently... */
typedef void (*thing_deallocator) (void *thing_to_be_deallocated);

{{/header}}
{{#body}}
/* for Native_Objects, we need to store the deallocator along with the
   actual object, so we'll keep our own data structure to do this, and
   this is what actually gets stored in the Javascript object, with the
   get() and set() routines hiding the details from the user */
/* if we are outputing this code in a language that has closures, we
   would be able to delete this object at the same time that we call
   the user's deallocator function; for now, we'll leak (at least) 2 pointer
   values every time an object gets deallocated */
typedef struct {
    jerry_object_native_info_t deallocator;
    void *thing;
} Native_Object;
{{/body}}

void Native_Object_set(void *thing, thing_deallocator deallocator, jerry_value_t object){{#header}};{{/header}}
{{#body}}
{
    Native_Object *new_thing = (Native_Object *)malloc(sizeof(Native_Object));

    new_thing->deallocator.free_cb = deallocator;
    new_thing->thing = thing;

    jerry_set_object_native_pointer(object, new_thing, &(new_thing->deallocator));
} /* Native_Object_set */
{{/body}}

void *Native_Object_get(jerry_value_t object){{#header}};{{/header}}
{{#body}}
{
    jerry_object_native_info_t *deallocator;
    Native_Object *thing;

    jerry_get_object_native_pointer(object, (void**)&thing, (const jerry_object_native_info_t **)&deallocator);

    if (thing->deallocator.free_cb != deallocator->free_cb)
    {
        fprintf(stderr, "Deallocator is different.\n");
	return NULL; /* TODO: is this the right thing in this case? */
    }
    if (thing == NULL)
    {
        fprintf(stderr, "The object has been deallocated.\n");
	return NULL; /* TODO: is the error message accurate? */
    }
    return thing->thing;
} /* Native_Object_get */
{{/body}}


{{#header}}
{{#has_callbacks}}
/* calls to functions residing in the Javascript environment require
   extra context; from the C-programmer's point of view, callbacks
   can be thought of as _being_ this context -- for example, when
   passing around a "callback", we'll actually pass around this
   context structure, and then the generator will generate #def's
   to wrap the generic call that uses this context into an easily
   used C function */
typedef struct {
    jerry_value_t function_value; /* Jerryscript's function pointer */
    jerry_value_t this_value;     /* i.e., "this" pointer */
} callback_context;
{{/has_callbacks}}

{{#sorted_types_list}}
{{#is_enum}} {{! ENUMS }}
typedef enum { {{#members}}{{{indentation}}}{{{name}}}{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} }{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}} {{/onlyOneMember}}{{{name}}};
{{/is_enum}}
{{#is_callback}}
typedef callback_context {{{name}}}_calling_context;
{{/is_callback}}
{{#is_dictionary}} {{! DICTIONARIES }}
typedef struct {
	{{#members}}
    {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array_object}}{{#is_array}}*{{/is_array}}{{/is_array_object}}{{^is_array_object}}{{#is_array}}_Array{{/is_array}}{{/is_array_object}} {{{name}}};
    {{/C_and_Jerryscript_Types}}
	{{/members}}
} {{name}};
{{/is_dictionary}}
{{! TODO: WHAT ABOUT PARTIAL INTERFACES? }}
{{#is_interface}}  {{! INTERFACES }}
{{! {{#NoInterfaceObject}}
typedef struct {
    {{#attributes}}
        {{#C_and_Jerryscript_Types}}
            {{#callback}}
    {{{C_Type}}}_calling_context{{#is_array}}_Array{{/is_array}} {{{name}}};
            {{/callback}}
            {{^callback}}
    {{{C_Type}}}{{#is_array}}_Array{{/is_array}} {{{name}}};
            {{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/attributes}}
} {{name}};
{{! SET UP #DEFS TO GET AT ATTRIBUTES OF THE INTERFACE}}
    {{#attributes}}
    {{#C_and_Jerryscript_Types}}
#define attribute_{{{interfaceName}}}_{{{name}}}{{#is_array}}_Array{{/is_array}} (extract_{{{interfaceName}}}_{{{name}}}{{#is_array}}_Array{{/is_array}}(this_val))
    {{/C_and_Jerryscript_Types}}
    {{/attributes}}
{{! {{/NoInterfaceObject}}
{{/is_interface}}

{{/sorted_types_list}}
{{/header}}

{{#header}}
/* INITIALIZATION FUNCTIONS */
{{#interfaces}}
void load_{{{name}}}_interface(void);
{{/interfaces}}

#define load_all_{{{moduleName}}}_interfaces {\
{{#hasOperations}}create_interface_prototypes_holder(); \{{/hasOperations}}
{{#interfaces}}
load_{{{name}}}_interface(); \
{{/interfaces}}
} /* load_all_{{{moduleName}}}_interfaces */
{{/header}}

{{! if we have an idl file with the "any" type, we'll have to create a
    union to hold all of the possible types }}
{{! we start with the list of primitive types supported by Jerryscript }}
{{#uses_any_type}}
{{#header}}
union {{{moduleName}}}_types_union {
    boolean bool_var;
    double double_var;
    char * string_var;
{{#any_type_list}}
    {{#objects}}
    {{{type}}} {{{type_name}}};
    {{/objects}}
    {{#callbacks.length}}
    /* all functions are represented with a jerry_value_t */
    jerry_value_t function_var;
    {{/callbacks.length}}
    {{#enums}}
    {{{type}}} {{{type_name}}};
    {{/enums}}
{{/any_type_list}}
}; /* {{{moduleName}}}_types_union */
{{/header}}
{{/uses_any_type}}

{{#header}}
/***********************IGNORE FUNCTIONS BELOW THIS LINE ****************/
#define jerry_get_int8_t_value (int8_t)jerry_get_number_value
#define jerry_get_uint8_t_value (uint8_t)jerry_get_number_value
#define jerry_get_int16_t_value (int16_t)jerry_get_number_value
#define jerry_get_uint16_t_value (uint16_t)jerry_get_number_value
#define jerry_get_int32_t_value (int32_t)jerry_get_number_value
#define jerry_get_uint32_t_value (uint32_t)jerry_get_number_value
#define jerry_get_int64_t_value (int64_t)jerry_get_number_value
#define jerry_get_uint64_t_value (uint64_t)jerry_get_number_value
#define jerry_get_float_value (float)jerry_get_number_value
#define jerry_get_double_value (double)jerry_get_number_value
#define jerry_get_bool_value (bool)jerry_get_boolean_value

{{/header}}

{{#uses_strings}}
#include <stdlib.h>
char *jerry_get_string_value(jerry_value_t string_value){{#header}};{{/header}}
{{#body}}
{
    int string_length = jerry_get_string_length(string_value);
    jerry_char_t *return_value = (jerry_char_t *)malloc(sizeof(jerry_char_t)*(string_length+1));

    int characters_copied = jerry_string_to_char_buffer(string_value,
                                        return_value, string_length);

    if (characters_copied != string_length)
    {
       fprintf(stderr, "PROBLEM WITH STRING COPY!\n");
       /*abort();*/
    }

    return_value[string_length]='\0';
    return (char *)return_value;
} /* jerry_get_string_value */
{{/body}}
{{/uses_strings}}

{{#uses_any_type}}
{{{moduleName}}}_types_union jerry_get_any_value(jerry_value_t any_value){{#header}};{{/header}}
{{#body}}
{
    {{{moduleName}}}_types_union return_value;
 
 {{! for now, we'll assume that "any" types are simply pass-through
     values headed to other javascript functions, and we won't try to
     do anything with them }}
{{! "IGNORE" is a made-up value designed to be ignored by mustache }}
{{^IGNORE}}
    return_value.function_var = any_value;
{{/IGNORE}}
{{#IGNORE}}
    /* Jerryscript only passes around six types: booleans, numbers (doubles),
        strings, objects, NULL, and undefined; we'll mimic the last two by
        setting the string value in the union to be null */
    if (jerry_value_is_boolean(any_value))
        return_value.bool_val = jerry_get_boolean(any_value);
    else if (jerry_value_is_number(any_value))
    	 return_value.double_var = jerry_get_number(any_value);
    else if (jerry_value_is_string(any_value))<
        return_value.string_var = jerry_get_string_value(any_value);
    else if (jerry_value_is_null(any_value) ||
             jerry_value_is_undefined(any_value))
    	 return_value.string_var = NULL;
    {{#any_type_list}}
    {{#objects.length}}
    else if (jerry_value_is_object(any_value))
    {
	{{#objects}} 
        {{^first_in_list}}else {{/first_in_list}}if
	{{/objects}}
    }
    {{/objects.length}}
    {{#callbacks.length}}
    else if (jerry_value_is_function(any_value))
        return_value.function_var = any_value;
    {{/callbacks.length}}
    {{/any_type_list}}
    else if (jerry_value_is_array(any_value))
    {
         fprintf(stderr, "WE DON'T DO ARRAYS YET.\n");
    }
    else
    {
        fprintf(stderr, "Unrecognized type in \"any\" variable.\n");
    }
{{/IGNORE}}
    return return_value;
} /* jerry_get_any_value */
{{/body}}
{{/uses_any_type}}

{{#variadic_types}}
{{#C_and_Jerryscript_Types}}
{{{C_Type}}}_Array jerry_get_array_of_{{{C_Type}}}(const jerry_value_t *argv,
                      const jerry_length_t argc, jerry_length_t starting_index){{#header}};{{/header}}
{{#body}}
{
    int number_of_elements = argc - starting_index;
    {{! CHECK FOR ZERO SIZE?!? }}
    {{{C_Type}}}_Array return_array = { number_of_elements,
                                           ({{{C_Type}}} *)malloc(sizeof({{{C_Type}}})*number_of_elements) };
    for(int i = starting_index, j = 0; i < argc; i++, j++)
        return_array.items[j] = jerry_get_{{{C_Type}}}_value(argv[i]);
    return return_array;
} /* jerry_get_array_of_{{{C_Type}}} */
{{/body}}
{{/C_and_Jerryscript_Types}}

{{/variadic_types}}

{{#dictionaries}}
{{! really, these functions should be named "get_..._struct" rather
    than "get_..._value" -- but b/c Jerryscript already has get_*_value
    for all of the builtin types, it's easier to follow that naming
    scheme for dictionaries and interfaces...}}
{{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t object_value = jerry_value_to_object(value);
    {{{name}}} return_struct;

    {{#is_array_object}}
    return_struct.length = jerry_get_array_length(object_value);
    {{#C_and_Jerryscript_Types}}
    return_struct.items = ({{{C_Type}}} *)malloc(sizeof({{{C_Type}}})*return_struct.length);
    for(int i = 0; i < return_struct.length; i++)
        return_struct.items[i] = ({{{C_Type}}})jerry_get_{{{C_Type}}}_value(jerry_get_property_by_index(object_value, i));
    {{/C_and_Jerryscript_Types}}
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t {{{name}}}_value = jerry_get_property(object_value, {{{name}}}_prop_name);
    {{#C_and_Jerryscript_Types}}
/*    return_struct.{{{name}}} = ({{{C_Type}}}{{#is_array}}{{#is_string}}*{{/is_string}}{{^is_string}}_Array{{/is_string}}{{/is_array}})jerry_get_{{#is_array}}{{{C_Type}}}{{/is_array}}{{^is_array}}{{{C_Type}}}{{/is_array}}{{#is_array}}_Array{{/is_array}}_value({{{name}}}_value);*/
    return_struct.{{{name}}} = ({{{C_Type}}}{{#is_array}}_Array{{/is_array}})jerry_get_{{#is_array}}{{{C_Type}}}{{/is_array}}{{^is_array}}{{{C_Type}}}{{/is_array}}{{#is_array}}_Array{{/is_array}}_value({{{name}}}_value);
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    jerry_release_value({{{name}}}_value);

    {{/members}}
    {{/is_array_object}}

    jerry_release_value(object_value);

    return return_struct;
} /* jerry_get_{{{name}}}_value */
{{/body}}

jerry_value_t jerry_create_{{{name}}}({{{name}}} x){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t new_jerry_value = jerry_create_object();

    {{#is_array_object}}
    {{#C_and_Jerryscript_Types}}
    for (int i = 0; i < x.length; i++)
    {
        jerry_value_t next = jerry_create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}(x.items[i]));
    	jerry_set_property_by_index(new_jerry_value, i, next);
    	jerry_release_value(next);
    }
    {{/C_and_Jerryscript_Types}}
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
    {{#C_and_Jerryscript_Types}}
    jerry_value_t {{{name}}}_value = jerry_create_{{^is_array}}{{{Jerryscript_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}(x.{{{name}}});
    {{/C_and_Jerryscript_Types}}
    jerry_set_property(new_jerry_value, {{{name}}}_prop_name, {{{name}}}_value);
    jerry_release_value({{{name}}}_value);
    jerry_release_value({{{name}}}_prop_name);

    {{/members}}
    {{/is_array_object}}

    return new_jerry_value;
    
} /* jerry_create_{{{name}}} */
{{/body}}

{{/dictionaries}}

{{#enums.length}}
{{! enumeration types are represented in Javascript as strings, so
    getting them across to Jerryscript and back requires some
    finagling }}
static int enum_index(char *target, char **array){{#header}};{{/header}}
{{#body}}
{
    int i = 0;
    while (array[i] != '\0')
        if (!strcmp(target, array[i]))
	    return i;
    /* fallthrough indicates the string's not in the array */
    return -1;
} /* enum_index */
{{/body}}
{{/enums.length}}

{{#enums}}
{{! we follow the same naming scheme as for dictionaries... }}

{{! we first need strings that match the enumeration values }}
{{#body}}
static char *{{{name}}}_strings[] = { {{#members}}{{{indentation}}}"{{{name}}}"{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} };{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}};{{/onlyOneMember}}
{{/body}}

{{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value){{#header}};{{/header}}
{{#body}}
{
    return ({{{name}}})enum_index(jerry_get_string_value(value), {{{name}}}_strings);
} /* jerry_get_{{{name}}}_value */
{{/body}}

jerry_value_t jerry_create_{{{name}}}({{{name}}} x){{#header}};{{/header}}
{{#body}}
{
    return jerry_create_string ((const jerry_char_t *) "{{{name}}}");
} /* jerry_create_{{{name}}} */
{{/body}}
{{/enums}}


{{#interfaces}}
{{#hasAttributes}}
/* attribute GETTERS */
{{#attributes}}
{{#C_and_Jerryscript_Types}}
{{^callback}}
{{{C_Type}}}{{#is_array}}_Array{{/is_array}} extract_{{{interfaceName}}}_{{{name}}} (jerry_value_t this_pointer){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t property_pointer = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t attribute_pointer = jerry_get_property(this_pointer, property_pointer);
    {{{C_Type}}} return_value = ({{{C_Type}}})jerry_get_{{{C_Type}}}_value(attribute_pointer);
    jerry_release_value(property_pointer);
    jerry_release_value(attribute_pointer);
    return return_value;
} /* extract_{{interfaceName}}_{{name}} */
{{/body}} {{! EXTRACT NON-CALLBACK ATTRIBUTE}}
{{/callback}}
{{! if the attribute is a callback, return the calling context for it }}
{{#callback}}
{{C_Type}}_calling_context extract_{{{interfaceName}}}_{{{name}}} (jerry_value_t this_pointer){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t property_pointer = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t attribute_pointer = jerry_get_property(this_pointer, property_pointer);

    jerry_release_value(property_pointer);

    return ({{C_Type}}_calling_context){attribute_pointer, this_pointer};
} /* extract_{{interfaceName}}_{{name}} */
{{/body}}
{{/callback}}

{{/C_and_Jerryscript_Types}}
{{/attributes}} {{! ATTRIBUTE GETTERS}}

{{/hasAttributes}}

{{/interfaces}}


/* if there are any callbacks, we'll use these wrapper functions to
   marshal the parameters for the function and then call the
   function through the interpreter */

{{#callbacks}}
{{#return_type}}{{{C_Type}}}{{/return_type}}
run_{{{name}}}_function(const {{{name}}}_calling_context {{{name}}}_context{{^arguments.length}}){{#header}};{{/header}}{{/arguments.length}}{{#arguments.length}},{{/arguments.length}}
{{#arguments}}{{{indentation}}}{{#C_and_Jerryscript_Types}}{{{C_Type}}} {{{name}}}{{{separator}}}{{/C_and_Jerryscript_Types}}{{/arguments}}{{#arguments.length}}{{#header}};{{/header}}{{/arguments.length}}
{{#body}}
{
{{#arguments}}{{#C_and_Jerryscript_Types}}
    jerry_value_t {{{name}}}_value = jerry_create_{{{Jerryscript_Type}}}({{{name}}});
{{/C_and_Jerryscript_Types}}{{/arguments}}

    jerry_value_t argv[] = { {{#arguments}}{{{name}}}_value{{^finalArgument}},{{/finalArgument}}{{/arguments}} };
    jerry_value_t jerry_return_value = jerry_call_function({{{name}}}_context.function_value,
							   {{{name}}}_context.this_value,
						           argv, {{{arguments.length}}});
	
    {{#return_type}}
    {{^voidReturnType}}
    return ({{{C_Type}}})jerry_get_{{{C_Type}}}_value(jerry_return_value);
    {{/voidReturnType}}
    {{/return_type}}
} /* run_{{{name}}}_function */
{{/body}}
{{/callbacks}} 


{{#interfaces}}
{{! INTERFACE GETTER/SETTER: }}
{{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t object_value = jerry_value_to_object(value);
    {{{name}}} return_struct;

    {{#attributes}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t {{{name}}}_value = jerry_get_property(object_value, {{{name}}}_prop_name);
    {{#C_and_Jerryscript_Types}}
    {{^callback}}
    return_struct.{{{name}}} = ({{{C_Type}}})jerry_get_{{{C_Type}}}_value({{{name}}}_value);
    {{/callback}}
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    jerry_release_value({{{name}}}_value);
//
    {{/attributes}}

    jerry_release_value(object_value);

    return return_struct;
} /* jerry_get_{{{name}}}_value */
{{/body}}

jerry_value_t jerry_create_{{{name}}}({{{name}}} x){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t dummy_jerry_value;
extern jerry_value_t create_{{{name}}}_interface_handler(const jerry_value_t,
					   const jerry_value_t,
					   const jerry_value_t *,
					   const jerry_length_t);
    jerry_value_t new_jerry_value = create_{{{name}}}_interface_handler(
							dummy_jerry_value,
							dummy_jerry_value,
							&dummy_jerry_value,
							0);
    {{#attributes}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    {{#C_and_Jerryscript_Types}}
    {{^callback}}
    jerry_value_t {{{name}}}_value = jerry_create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}x.{{{name}}});
    jerry_set_property(new_jerry_value, {{{name}}}_prop_name, {{{name}}}_value);
    jerry_release_value({{{name}}}_value);
    {{/callback}}
    {{! TODO: if it's a callback, apply set_external_handler?}}
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    {{/attributes}}

    return new_jerry_value;    
} /* jerry_create_{{{name}}} */
{{/body}}

{{/interfaces}}

{{#hasOperations}}
void register_function_call(jerry_value_t enclosing_object,
				   const char *function_name,
       			           jerry_external_handler_t handler){{#header}};{{/header}}
{{#body}}
{
  /* Create a JS function object and wrap into a jerry value */
  jerry_value_t function_object = jerry_create_external_function(handler);

  /* Set the native function as a property of the enclosing object
     (either the global object, or a user-define object) */
  jerry_value_t prop_name =
                 jerry_create_string((const jerry_char_t *) function_name);
  jerry_set_property(enclosing_object, prop_name, function_object);
  jerry_release_value(function_object);
  jerry_release_value(prop_name);
} /* register_function_call */

{{/body}}
{{! for each interface, we load the operations into an object that we
    can then apply to each instance; this saves us from creating an
    object and then assigning each of the operations to it every time
    we create a new instance of the interface; the problem is that
    when they make Jerryscript multithreaded, we need someplace to
    store the prototype object that isn't in a (C) global variable --
    the safest place is in the Javascript side, so we'll create an
    object here that will hold all of the interface prototypes as we
    create/use them }}
{{#body}}
{{! all of the prototype objects will hoook to this global object }}
    /* add something meaningless to the ends of the name to ensure we
       don't write over a user name*/
static const char *q36 = "q36_interface_prototypes_holder_q36";
static const jerry_char_t q36_script[] = "var q36_interface_prototypes_holder_q36 = {};";
{{/body}}
void create_interface_prototypes_holder(){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t new_prototypes_holder = jerry_create_object();
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prototype_holder_name =
                                jerry_create_string((const jerry_char_t *)q36);
    /* register the new object and immediately release jerry_value */
    jerry_release_value(jerry_set_property(global_object,
	                                   prototype_holder_name,
					   new_prototypes_holder));
    jerry_release_value(prototype_holder_name);
    jerry_release_value(global_object);
    jerry_release_value(new_prototypes_holder);
} /* create_interface_prototypes_holder */

{{/body}}

{{! next, we'll need a getter and setter for each prototype }}
/* helper function for the getter/setters, below */
{{#body}}
static jerry_value_t get_prototypes_holder(void)
{
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prototypes_holder_property =
                             jerry_create_string((const jerry_char_t *)q36);
    jerry_value_t prototypes_holder = 
                  jerry_get_property(global_object, prototypes_holder_property);
    jerry_release_value(global_object);
    jerry_release_value(prototypes_holder_property);

    return prototypes_holder;
} /* get_prototypes_holder */

{{/body}}
jerry_value_t get_prototype(char * interface_name){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prototypes_holder = get_prototypes_holder();
    jerry_value_t interface_property =
                     jerry_create_string((const jerry_char_t *)interface_name);
    jerry_value_t prototype = jerry_get_property(prototypes_holder,
                                                  interface_property);
    jerry_release_value(prototypes_holder);
    jerry_release_value(interface_property);

    return prototype;
} /* get_prototype */

{{/body}}
void register_prototype(char * interface_name, jerry_value_t new_prototype){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prototypes_holder = get_prototypes_holder();
    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) interface_name);
    /* set the prototype and release the return value without any check */
    jerry_release_value(jerry_set_property (prototypes_holder,
                                            prop_name, new_prototype));

    /* clean up */
    jerry_release_value(prototypes_holder);
    jerry_release_value(prop_name);
} /* register_prototype */

{{/body}}

{{/hasOperations}}

{{#header}}
#endif /* {{moduleName}}_TYPES_H_ */
{{/header}}
{{/TAG_USED_TO_FORCE_MUSTACHE_TO_OBEY_VERTICAL_WHITESPACING}}
