{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .c and the .h
    *_Types files -- look for the "body" and "header" markers }}
{{#print_generation_message}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{/print_generation_message}}
{{#header}}
#ifndef UTILITY_FUNCTIONS_H_
#define UTILITY_FUNCTIONS_H_
{{/header}}

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

{{#header}}
#include "jerryscript.h"
#include "arg.h"

{{/header}}
{{#body}}
#include "{{{utilities_filename}}}.h"

{{/body}}
{{#header}}
typedef char * string;
{{! if we are purposely removing the abstraction by explicitly naming
    Jerryscript types, then the following typedef's aren't necessary }}
{{^Interpreter.tied_to_jerryscript}}
typedef jerry_value_t {{{Interpreter.Type}}};
typedef jerry_error_t {{{Interpreter.error_type}}};
typedef jerry_object_native_info_t {{{Interpreter.checksum_type}}};
{{/Interpreter.tied_to_jerryscript}}
typedef {{{Interpreter.Type}}} _object;
typedef string Error;

#define {{{Interpreter.interpreter}}}_get_Error_value {{{Interpreter.interpreter}}}_get_string_value
#define {{{Interpreter.interpreter}}}_create_Error(x) {{{Interpreter.interpreter}}}_create_string((const jerry_char_t *)x)
#define {{{Interpreter.interpreter}}}_value_is_Error {{{Interpreter.interpreter}}}_value_is_string
#define debug_print_Error debug_print_string

{{! the WebIDL type "object" conflicts with some of the Jerryscript
    calls, so we define WebIDL's type as "_object" so that there
    won't be name conflicts if somebody uses the "tied_to_jerryscript"
    flag...}}
#define {{{Interpreter.interpreter}}}_get__object_value(x) (x)
#define {{{Interpreter.interpreter}}}_create__object(x) (x)
#define {{{Interpreter.interpreter}}}_value_is__object jerry_value_is_object
#define _object_constructor jerry_create_object

/* each type needs to have its own unique id (uid) so that we can
   build union types out of multiple types and differentiate between
   them; at creation of a type, we'll call this bookkeeper to give
   that type its uid */
/* since we know up front all of the WebIDL types, we'll go ahead and
   give them #defines -- this lets us use a switch statement inside of
   the {{{Interpreter.interpreter}}}_create_any function, which is a little more
   efficient */
#define boolean_uid          0
#define byte_uid             1
#define octet_uid            2
#define short_uid            3
#define unsignedshort_uid    4
#define long_uid             5
#define unsignedlong_uid     6
#define longlong_uid         7
#define unsignedlonglong_uid 8
#define float_uid            9
#define double_uid           10
#define string_uid           11
#define ArrayBuffer_uid      12
{{! any_uid MUST BE THE HIGHEST OF THESE PREDEFINED VALUES! (b/c it's used
   as the initializer for the counter in get_type_uid, below) }}
#define any_uid              13

{{/header}}
int get_type_uid(void){{#header}};{{/header}}
{{#body}}
{
    static int counter = any_uid+1;

    return counter++;
} /* get_type_uid */
{{/body}}

/* we'll give all of the atomic WebIDL types their own uids so that
   all types are treated the same way; these should be treated as
   read-only values */

/* NOTE: we only handle the above types.  Missing are: ByteString,
   USVString, Object, and Symbol. */

{{#header}}
typedef bool boolean;
typedef int8_t byte;
typedef uint8_t octet;
/*typedef int16_t short;*/
typedef uint16_t unsignedshort;
/*typedef int32_t long;*/
typedef uint32_t unsignedlong;
typedef int64_t longlong;
typedef uint64_t unsignedlonglong;
typedef float unrestricted_float;
typedef double unrestricted_double;
typedef string DOMString;
typedef string ByteString;
typedef string USVString;
typedef jerry_value_t this;


/* we currently don't provide an interface for overlays (typedarray) of
   ArrayBuffer's... */
typedef struct {
    uint32_t length;
    uint8_t *data;
} ArrayBuffer;

{{/header}}
/* write values from a C ArrayBuffer into a Javascript ArrayBuffer */
int ArrayBuffer_write(ArrayBuffer source, {{{Interpreter.Type}}} target){{#header}};{{/header}}
{{#body}}
{
    if (!jerry_value_is_arraybuffer(target))
    {
	fprintf(stderr, "Trying to write to a Javascript value that is not an ArrayBuffer.\n");
	return 0;
    }
    else
    {
	int target_size = jerry_get_arraybuffer_byte_length(target);

	if (target_size < source.length)
	{
	    fprintf(stderr, "Javascript ArrayBuffer is too small.\n");
	    return 0;
	}
	else
	{
	    int bytes_written = jerry_arraybuffer_write(target,
						  0 /* starting offset */,
						  source.data,
						  source.length);
	    if (bytes_written < source.length)
	    {
		fprintf(stderr, "Error on writing ArrayBuffer.\n");
		return 0;
	    }
	    else
		return bytes_written;
	}
    }

} /* ArrayBuffer_write */

{{/body}}

/* read values from a Javascript ArrayBuffer into a C ArrayBuffer */
/* SIDE EFFECT: calls malloc */
int ArrayBuffer_read({{{Interpreter.Type}}} source, ArrayBuffer *target){{#header}};{{/header}}
{{#body}}
{
    if (target->data == NULL)
	target->data = (unsigned char *)malloc(target->length*sizeof(uint8_t));

    if (target->data == NULL)
    {
	fprintf(stderr, "out of memory.\n");
	return 0;
    }
    else
    {
	int source_size = jerry_get_arraybuffer_byte_length(source);

	if (source_size < target->length)
	{
	    fprintf(stderr, "ArrayBuffer size mismatch on read.\n");
	    return 0;
	}
	else
	{
	    int bytes_read = jerry_arraybuffer_read(source,
						 0 /* starting offset */,
						 target->data,
						 target->length);
	    if (bytes_read != target->length)
		fprintf(stderr, "incorrect ArrayBuffer read.\n");

	    return bytes_read;
	}
    }
} /* ArrayBuffer_read */

{{/body}}

/* creates a new ArrayBuffer, copies "value"'s data into it, and returns
   the struct */
ArrayBuffer {{{Interpreter.interpreter}}}_get_ArrayBuffer_value({{{Interpreter.Type}}} value){{#header}};{{/header}}
{{#body}}
{
    ArrayBuffer new_ArrayBuffer = {0, NULL};

    new_ArrayBuffer.length = jerry_get_arraybuffer_byte_length(value);

    if (new_ArrayBuffer.length == 0)
	fprintf(stderr, "zero-length buffer passed in to get_ArrayBuffer_value.\n");
    else
	ArrayBuffer_read(value, &new_ArrayBuffer);

    return new_ArrayBuffer;
}; /* {{{Interpreter.interpreter}}}_get_ArrayBuffer_value */

{{/body}}

/* NOTE: cannot pass in a zero-length ArrayBuffer! */
{{{Interpreter.Type}}} {{{Interpreter.interpreter}}}_create_ArrayBuffer(ArrayBuffer ArrayBuffer_value){{#header}};{{/header}}
{{#body}}
{
    return jerry_create_arraybuffer_external(ArrayBuffer_value.length,
				      (uint8_t *)ArrayBuffer_value.data,
				      free);
}; /* {{{Interpreter.interpreter}}}_create_ArrayBuffer */

{{/body}}

bool {{{Interpreter.interpreter}}}_value_is_ArrayBuffer({{{Interpreter.Type}}} ArrayBuffer_value){{#header}};{{/header}}
{{#body}}
{
    return jerry_value_is_arraybuffer(ArrayBuffer_value);
}; /* {{{Interpreter.interpreter}}}_value_is_ArrayBuffer */

{{/body}}

ArrayBuffer ArrayBuffer_constructor(void){{#header}};{{/header}}
{{#body}}
{
    return (ArrayBuffer){0, NULL};
}; /* ArrayBuffer_constructor */

{{/body}}

/* this is a null call, since ArrayBuffer exists on the Javascript side */
void initialize_ArrayBuffer_(void){{#header}};{{/header}}
{{#body}}
{
}; /* initialize_Array_Buffer_ */

{{/body}}

{{#header}}
/* WebIDL's "any" type: */
typedef struct
{
    int          union_type; /* describes the type */
    union {
	bool     boolean_field;
	byte   byte_field;
	octet  octet_field;
	short short_field;
	unsignedshort unsignedshort_field;
	long  long_field;
	unsignedlong unsignedlong_field;
	longlong  longlong_field;
	unsignedlonglong unsignedlonglong_field;
	float    float_field;
	double   double_field;
	string   string_field;
    } value;
} any;

/* for now, we'll implement WebIDL's JSON type as an Any */
/* TODO: JSON types are not really equivalent to the "any" type... */
typedef any JSON;
#define {{{Interpreter.interpreter}}}_get_JSON_value {{{Interpreter.interpreter}}}_get_any_value
#define {{{Interpreter.interpreter}}}_create_JSON {{{Interpreter.interpreter}}}_create_any
#define {{{Interpreter.interpreter}}}_value_is_JSON {{{Interpreter.interpreter}}}_value_is_any
#define JSON_constructor any_constructor
#define initialize_JSON_ initialize_any_
#define debug_print_JSON debug_print_any


{{/header}}
/* for the any type, we'll aribtrarily make the default value a long
   and set it to zero */
any any_constructor(void){{#header}};{{/header}}
{{#body}}
{
    any new_any;
    new_any.union_type = long_uid;
    new_any.value.long_field = 0;
    return new_any;
} /* any_constructor */
{{/body}}

/* NOTE: Jerryscript only has three types that "value" can be: string,
   boolean, or number (double) ... */
any {{{Interpreter.interpreter}}}_get_any_value({{{Interpreter.Type}}} value){{#header}};{{/header}}
{{#body}}
{
    any return_value;

    if (jerry_value_is_number(value))
    {
	return_value.union_type = double_uid;
	return_value.value.double_field = jerry_get_number_value(value);
    }
    else if (jerry_value_is_boolean(value))
    {
	return_value.union_type = boolean_uid;
	return_value.value.boolean_field = jerry_get_boolean_value(value);
    }
    else if (jerry_value_is_string(value))
    {
	return_value.union_type = string_uid;
	return_value.value.string_field = {{{Interpreter.interpreter}}}_get_string_value(value);
    }
    else /* ERROR!  TODO: do something here... */
	;

    return return_value;
} /* {{{Interpreter.interpreter}}}_get_any */

{{/body}}
{{{Interpreter.Type}}} {{{Interpreter.interpreter}}}_create_any(any any_value){{#header}};{{/header}}
{{#body}}
{
    if (any_value.union_type == boolean_uid)
	return {{{Interpreter.interpreter}}}_create_boolean(any_value.value.boolean_field);
    else if (any_value.union_type == string_uid)
	return {{{Interpreter.interpreter}}}_create_string(
			   (const jerry_char_t *)any_value.value.string_field);
    else /* one of the number types */
    {
	switch(any_value.union_type)
	{
	    case byte_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.byte_field);
	    case octet_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.octet_field);
	    case short_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.short_field);
	    case unsignedshort_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.unsignedshort_field);
	    case long_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.long_field);
	    case unsignedlong_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.unsignedlong_field);
	    case longlong_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.longlong_field);
	    case unsignedlonglong_uid:
		return
		    {{{Interpreter.interpreter}}}_create_number(any_value.value.unsignedlonglong_field);
	    case float_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.float_field);
	    case double_uid:
		return {{{Interpreter.interpreter}}}_create_number(any_value.value.double_field);

	    default: /* ERROR!  TODO: maybe report to the user? */
		/* abort(); */
		return {{{Interpreter.interpreter}}}_create_undefined();
	}
    }
} /* {{{Interpreter.interpreter}}}_create_any */

{{/body}}
bool {{{Interpreter.interpreter}}}_value_is_any({{{Interpreter.Type}}} thing_value){{#header}};{{/header}}
{{#body}}
{
    return (jerry_value_is_number(thing_value) ||
    	    jerry_value_is_boolean(thing_value) ||
    	    jerry_value_is_string(thing_value));
} /* {{{Interpreter.interpreter}}}_value_is_any */
{{/body}}

/* returns true if the Javascript object pointed to by "thing" has "name"
   as one of its fields */
bool {{{Interpreter.interpreter}}}__has_own_property({{{Interpreter.Type}}} thing, string name){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name = jerry_create_string((const jerry_char_t *)name);
    jerry_value_t jerry_boolean = jerry_has_own_property(thing, prop_name);
    bool return_value = jerry_get_boolean_value(jerry_boolean);
    jerry_release_value(jerry_boolean);
    jerry_release_value(prop_name);

    return return_value;
} /* {{{Interpreter.interpreter}}}__has_own_property */

{{/body}}
/* returns true if the Javascript object pointed to by "thing" has "name"
   as one of its fields */
bool {{{Interpreter.interpreter}}}__has_property({{{Interpreter.Type}}} thing, string name){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name = jerry_create_string((const jerry_char_t *)name);
    jerry_value_t jerry_boolean = jerry_has_property(thing, prop_name);
    bool return_value = jerry_get_boolean_value(jerry_boolean);

    jerry_release_value(jerry_boolean);
    jerry_release_value(prop_name);

    return return_value;
} /* {{{Interpreter.interpreter}}}__has_property */
{{/body}}

{{#header}}
/* calls to functions residing in the Javascript environment require
   extra context; from the C-programmer's point of view, callbacks
   can be thought of as _being_ this context -- for example, when
   passing around a "callback", we'll actually pass around this
   context structure, and then the generator will generate #def's
   to wrap the generic call that uses this context into an easily
   used C function */
typedef struct {
    {{{Interpreter.Type}}} function_value; /* Jerryscript's function pointer */
    {{{Interpreter.Type}}} this_value;     /* "this" pointer */
} calling_context;

{{/header}}
/* each WebIDL construct (dictionary, callback, interface, or enum)
   has a registrator function that sticks its initialization routine
   into a table of function pointers (this is before main starts --
   the registrator functions are attributed with
   __attribute(constructor)), and this is the function that runs all
   of those functions; it must be called after Jerryscript is
   initialized */
/* all of the initialization functions have a void(*)(void) signature,
   and they are stored in the following table: */
{{#header}}typedef void (*webidl_construct_initializer)(void);{{/header}}
{{#body}}
/* TODO: reason about whether all of the global, static variables in
   this file are amenable to running in a multi-threaded environment */
static int function_count = 0;
static webidl_construct_initializer *initializer_list = NULL;

{{/body}}
void register_initialization_function(webidl_construct_initializer initializer){{#header}};{{/header}}
{{#body}}
{
    static int list_size = 8;

    /* this conditional is just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (initializer_list == NULL) /* first call; get some memory */
        initializer_list = malloc(sizeof(webidl_construct_initializer) *
	 		          list_size);
    else if (function_count == list_size) /* need to grow the list */
    {
        list_size *= 2;
	initializer_list = realloc(initializer_list,
		          (sizeof(webidl_construct_initializer) * list_size));
	/* TODO: check for NULL return value */
    }
    initializer_list[function_count++] = initializer;
} /* register_initialization_function */
{{/body}}
{{#header}}
typedef {{{Interpreter.Type}}} (*Module_Creation_Function)(void);
{{/header}}
{{#body}}

/* WebIDL constructs that have the "ReturnFromRequire" external
   attribute set cannot be created by "new", but, rather, are the values
   returned from a call to "require" (we define that function, below); we
   store a mapping of the name given to "require" and the function that
   creates the construct, and then our "require" function will look up
   the function and dispatch it */

/* the constructs that are returned from a "require" are stored in
   this table; they map a module name with its create function */
typedef struct {
    char *function_name;
    Module_Creation_Function creator;
} Require_Table_Entry;

static int require_table_entry_count = 0;
static Require_Table_Entry *mapping_for_require;

{{/body}}
void register_require_function(string module_name,
                               Module_Creation_Function constructor_function){{#header}};{{/header}}
{{#body}}
{
    static int table_capacity = 8;

    /* this conditional is just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (mapping_for_require == NULL) /* first call; get some memory */
        mapping_for_require = malloc(sizeof(Require_Table_Entry) *
	 		             table_capacity);
    else if (require_table_entry_count == table_capacity) /* need to grow the list */
    {
        table_capacity *= 2;
	mapping_for_require = realloc(mapping_for_require,
		                (sizeof(Require_Table_Entry) * table_capacity));
	/* TODO: check for NULL return value */
    }
    /* TODO: check to see if all of the module names are unique */
    mapping_for_require[require_table_entry_count++] =
                     (Require_Table_Entry){module_name, constructor_function};
} /* register_require_function */

{{/body}}
{{#body}}
/* this function provides "require" to mimic the behavior of
   node.js's "require" */
static {{{Interpreter.Type}}} my_require(const {{{Interpreter.Type}}} func_value,
             			   const {{{Interpreter.Type}}} this_value,
             			   const {{{Interpreter.Type}}} *args_p,
				   const jerry_length_t args_cnt)
{
{{! TODO: error-check parameter! }}
    /* get the argument passed in */
    string module_name = {{{Interpreter.interpreter}}}_get_string_value(args_p[0]);

    /* look it up in the table */
    int target_index;
    for(target_index=0; target_index<require_table_entry_count; target_index++)
    	if (!strcmp(mapping_for_require[target_index].function_name,
	            module_name))
	    break;

    /* can't find the module? exit gracefully */
    if (target_index == require_table_entry_count)
    {
{{! TODO: add the name of the module to the error message }}
        return jerry_create_error (JERRY_ERROR_TYPE,
                             	(const jerry_char_t *) "Can't find the module");
    }

    /* call the function */
    return mapping_for_require[target_index].creator();
} /* my_require */

{{/body}}
void initialize_all_webidl_constructs(void){{#header}};{{/header}}
{{#body}}
{
    /* run all of the WebIDL constructs that have registered their respective
       initialization routines into the "initializer_list" table */
     for(int i = 0; i < function_count; i++)
        initializer_list[i](); /* each entry is a function pointer, so
				  with the "()", these are calls */

    /* create "require" in the global namespace */
    jerry_value_t require_function = jerry_create_external_function(my_require);
    jerry_value_t require_name =
                         jerry_create_string((const jerry_char_t *) "require");
    jerry_value_t global_object = jerry_get_global_object();
    jerry_release_value(jerry_set_property(global_object,
					   require_name, require_function));
    jerry_release_value(global_object);
    jerry_release_value(require_name);
    jerry_release_value(require_function);

} /* initialize_all_webidl_constructs */

{{/body}}

{{#header}}
#ifndef INTERFACE_EXTRACT
#define INTERFACE_EXTRACT(self, InterfaceName, AttributeName) \
	extract_##InterfaceName##_##AttributeName(self)
#endif /* INTERFACE_EXTRACT */

#ifndef INTERFACE_INSERT
#define INTERFACE_INSERT(self, InterfaceName, AttributeName, value) \
	insert_##InterfaceName##_##AttributeName(self, value)
#endif /* INTERFACE_INSERT */

/***********************IGNORE FUNCTIONS BELOW THIS LINE ****************/

/* we don't check the type of each thing while outputting code -> we
   assume that there'll be a "_create/get_thing/is_of_type" function for
   every type, so for the atomic types, we'll need a name mapping */
#define {{{Interpreter.interpreter}}}_get_int8_t_value (int8_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_uint8_t_value (uint8_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_int16_t_value (int16_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_uint16_t_value (uint16_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_int32_t_value (int32_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_uint32_t_value (uint32_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_int64_t_value (int64_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_uint64_t_value (uint64_t)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_float_value (float)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_double_value (double)jerry_get_number_value
#define {{{Interpreter.interpreter}}}_get_bool_value (bool)jerry_get_boolean_value

/* "byte" is the type of the ArrayBuffer type */
#define {{{Interpreter.interpreter}}}_get_byte_value (byte)jerry_get_number_value
//#define interpreter_get_octet_value (octet)jerry_get_number_value
//#define interpreter_get_short_value (short)jerry_get_number_value
//#define interpreter_get_unsignedshort_value (unsignedshort)jerry_get_number_value
//#define interpreter_get_long_value (long)jerry_get_number_value
//#define interpreter_get_unsignedlong_value (unsignedlong)jerry_get_number_value
//#define interpreter_get_longlong_value (longlong)jerry_get_number_value
//#define interpreter_get_unsignedlonglong_value (unsignedlonglong)jerry_get_number_value
#define interpreter_get_boolean_value (boolean)jerry_get_boolean_value

#define {{{Interpreter.interpreter}}}_get_this_value(x) (x)
#define this_constructor() 0

/* we check value types using their C-type names, although the checks
   translate into checking for synonymous Javascript types */
#define {{{Interpreter.interpreter}}}_value_is_int8_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_uint8_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_int16_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_uint16_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_int32_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_uint32_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_int64_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_uint64_t (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_float (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_double (bool)jerry_value_is_number
#define {{{Interpreter.interpreter}}}_value_is_bool (bool)jerry_value_is_boolean
#define {{{Interpreter.interpreter}}}_value_is_string (bool)jerry_value_is_string


/* "byte" is the type of the ArrayBuffer type */
#define {{{Interpreter.interpreter}}}_value_is_byte (bool)jerry_value_is_number
//#define interpreter_value_is_octet (bool)jerry_value_is_number
//#define interpreter_value_is_short (bool)jerry_value_is_number
//#define interpreter_value_is_unsignedshort (bool)jerry_value_is_number
//#define interpreter_value_is_long (bool)jerry_value_is_number
//#define interpreter_value_is_unsignedlong (bool)jerry_value_is_number
//#define interpreter_value_is_longlong (bool)jerry_value_is_number
//#define interpreter_value_is_unsignedlonglong (bool)jerry_value_is_number
#define interpreter_value_is_boolean (bool)jerry_value_is_boolean

#define {{{Interpreter.interpreter}}}_value_is_float (bool)jerry_value_is_number

#define {{{Interpreter.interpreter}}}_value_is_number (bool)jerry_value_is_number

/* I don't know how many of these are automatically generated -- TODO */
{{^interpreter.tied_to_jerryscript}}
#define interpreter_create_array     jerry_create_array
#define interpreter_create_boolean   jerry_create_boolean
#define interpreter_create_number    jerry_create_number
#define interpreter_create_null      jerry_create_null
#define interpreter_create_string(s) jerry_create_string((jerry_char_t *)(s))
#define interpreter_create_undefined jerry_create_undefined
{{/interpreter.tied_to_jerryscript}}

/* "byte" is the type of the ArrayBuffer type */
#define {{{Interpreter.interpreter}}}_create_byte (bool)jerry_create_number
//#define interpreter_create_octet (bool)jerry_create_number
// #define interpreter_create_short (bool)jerry_create_number
// #define interpreter_create_unsignedshort (bool)jerry_create_number
// #define interpreter_create_long (bool)jerry_create_number
// #define interpreter_create_unsignedlong (bool)jerry_create_number
// #define interpreter_create_longlong (bool)jerry_create_number
// #define interpreter_create_unsignedlonglong (bool)jerry_create_number

#define {{{Interpreter.interpreter}}}_create_float jerry_create_number
#define {{{Interpreter.interpreter}}}_create_double (bool)jerry_create_number


#define {{{Interpreter.interpreter}}}_create_int8_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_uint8_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_int16_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_uint16_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_int32_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_uint32_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_int64_t (bool)jerry_create_number
#define {{{Interpreter.interpreter}}}_create_uint64_t (bool)jerry_create_number

#define {{{Interpreter.interpreter}}}_create_bool   jerry_create_boolean

#define double_constructor() (0.0)
#define float_constructor() (0.0)
#define long_constructor() (0) 
#define short_constructor() (0) 
#define void_constructor() (0) 

#ifndef GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR
#define GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR(this_val, native_object, C_type_identifier) \
{ \
    jerry_error_t error_check; \
    native_object = Native_Object_get(this_val, &C_type_identifier, &error_check); \
    if (error_check) \
        return error_check; \
} /*GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR */
#endif /* ifndef GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR */

{{/header}}

{{^original_arg_handling}}
{{#header}}

/* for strict parameter-checking (e.g., a "boolean" parameter has to
   have a "true/false" value, it can't be an integer), comment out the
   first #define, and un-comment the second... */
#define COERCION_POLICY                 JERRYX_ARG_COERCE
/* #define COERCION_POLICY              JERRYX_ARG_NO_COERCE */

#define ROUNDING_POLICY 	     JERRYX_ARG_ROUND
#define CLAMPING_POLICY 	     JERRYX_ARG_CLAMP
typedef enum {INTERPRETER_ARG_OPTIONAL=JERRYX_ARG_OPTIONAL,
	      INTERPRETER_ARG_REQUIRED=JERRYX_ARG_REQUIRED
} {{{Interpreter.interpreter}}}_arg_optional_flag_enum_type;

/* all of the {{{Interpreter.interpreter}}}_arg_* functions take a pointer to the
   result and a the optional flag (defined above, either
   INTERPRETER_ARG_OPTIONAL or INTERPRETER_ARG_REQUIRED) */
/* for brevity, "x" == value to be defined, and "z" = optional-flag value) */
#define {{{Interpreter.interpreter}}}_arg_number        jerryx_arg_number
#define {{{Interpreter.interpreter}}}_arg_bool(x, z) jerryx_arg_boolean(x, COERCION_POLICY, (jerryx_arg_optional_t)z)
#define {{{Interpreter.interpreter}}}_arg_int8_t(x, z)    jerryx_arg_int8(x, ROUNDING_POLICY, \
				     		       	 CLAMPING_POLICY, \
						       	 COERCION_POLICY, \
						       	 (jerryx_arg_optional_t)z)
#define {{{Interpreter.interpreter}}}_arg_uint8_t(x, z)   jerryx_arg_uint8(x, ROUNDING_POLICY, \
				     			  CLAMPING_POLICY, \
							  COERCION_POLICY, \
							  (jerryx_arg_optional_t)z)

#define {{{Interpreter.interpreter}}}_arg_int16_t(x, z)   jerryx_arg_int16(x, ROUNDING_POLICY, \
				     			  CLAMPING_POLICY, \
							  COERCION_POLICY, \
							  (jerryx_arg_optional_t)z)
#define {{{Interpreter.interpreter}}}_arg_uint16_t(x, z)  jerryx_arg_uint16(x, ROUNDING_POLICY, \
				     			   CLAMPING_POLICY, \
							   COERCION_POLICY, \
							   (jerryx_arg_optional_t)z)
#define {{{Interpreter.interpreter}}}_arg_int32_t(x, z)   jerryx_arg_int32(x, ROUNDING_POLICY, \
				     			  CLAMPING_POLICY, \
							  COERCION_POLICY, \
							  (jerryx_arg_optional_t)z)
#define {{{Interpreter.interpreter}}}_arg_uint32_t(x, z)  jerryx_arg_uint32(x, ROUNDING_POLICY, \
				     			   CLAMPING_POLICY, \
							   COERCION_POLICY, \
							   (jerryx_arg_optional_t)z)

/* CAUTION: THIS FUNCTION CALLS malloc! */
#define {{{Interpreter.interpreter}}}_arg_string(x, z) \
            jerryx_arg_custom(x, \
	    		     (uintptr_t)&((uintptr_t []){(uintptr_t)COERCION_POLICY, \
			                     (uintptr_t)z}), \
			      {{{Interpreter.interpreter}}}_arg_to_string)

#define {{{Interpreter.interpreter}}}_arg__object(x, z) \
            jerryx_arg_custom(x, \
	    		     (uintptr_t)&((uintptr_t []){(uintptr_t)COERCION_POLICY, \
			                     (uintptr_t)z}), \
			      {{{Interpreter.interpreter}}}_arg_to__object)

#define {{{Interpreter.interpreter}}}_arg_string_no_malloc jerryx_arg_string

/* this one has to use its own function, b/c Jerryscript doesn't have
   a floating-point version */
#define {{{Interpreter.interpreter}}}_arg_float(x, z) \
            jerryx_arg_custom(x, \
	    		     (uintptr_t)&((uintptr_t []){(uintptr_t)COERCION_POLICY, \
			                     (uintptr_t)z}), \
			      {{{Interpreter.interpreter}}}_arg_to_float)
#define {{{Interpreter.interpreter}}}_arg_double(x, z)  jerryx_arg_number(x, COERCION_POLICY, (jerryx_arg_optional_t)z)
{{/header}}

/* the transform function for floating-point numbers is defined only
   for doubles, so we need a wrapper that will call the version for
   doubles and then convert that value to a float */
jerry_value_t {{{Interpreter.interpreter}}}_arg_to_float(jerryx_arg_js_iterator_t *js_arg_iter_p,
			               const jerryx_arg_t *c_arg_p){{#header}};{{/header}}
{{#body}}
{
    double intermediate_result = 0.0;
    uintptr_t *extra_info = (uintptr_t*)(c_arg_p->extra_info);
    /* we naively access c_arg_p as if we know(!) that there are two
       parameters, one for the coercion flag, and one for the optional flag */
    jerryx_arg_t get_double = {{{Interpreter.interpreter}}}_arg_number(&intermediate_result,
						     extra_info[0],
					             extra_info[1]);
    jerry_value_t convert_to_double_result =
            	     get_double.func(js_arg_iter_p, &get_double);

    if (!jerry_value_is_error(convert_to_double_result))
        *((float*)(c_arg_p->dest)) = (float)intermediate_result;
    return convert_to_double_result;
} /* {{{Interpreter.interpreter}}}_arg_to_float */
{{/body}}

/* the transform function for string values has to do some memory
   manipulation, so we need a wrapper that will do the extra steps */
jerry_value_t {{{Interpreter.interpreter}}}_arg_to_string(jerryx_arg_js_iterator_t *js_arg_iter_p,
			               const jerryx_arg_t *c_arg_p){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t string_value = jerryx_arg_js_iterator_pop(js_arg_iter_p);
    string temp = NULL;

    /* TODO: really, we should be checking to see if we can coerce whatever
       the value is into a string -- I think(?) the only error condition
       here would be if "string_value" is undefined... */
    if (!jerry_value_is_string(string_value))
	return jerry_create_error(JERRY_ERROR_TYPE,
                             	  (const jerry_char_t *) "Expected a string.");

    temp = {{{Interpreter.interpreter}}}_get_string_value(string_value);
    if (temp == NULL)
    {
	return jerry_create_error(JERRY_ERROR_TYPE,
			   (const jerry_char_t *) "Null string found.");
    }
    else
    {
	*((string *)(c_arg_p->dest)) = temp;
	return jerry_create_undefined();
    }
} /* {{{Interpreter.interpreter}}}_arg_to_string */
{{/body}}


/* the transform function for "object" doesn't actually do anything other
   than check to see if the jerry_value_t is an object */
jerry_value_t {{{Interpreter.interpreter}}}_arg_to__object(jerryx_arg_js_iterator_t *js_arg_iter_p,
			               const jerryx_arg_t *c_arg_p){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t _object_value = jerryx_arg_js_iterator_pop(js_arg_iter_p);
    if (!jerry_value_is_object(_object_value))
    	return jerry_create_error(JERRY_ERROR_TYPE,
                             	  (const jerry_char_t *) "Expected an object.");
    *((jerry_value_t *)c_arg_p->dest) = _object_value;
    return jerry_create_undefined();
} /* {{{Interpreter.interpreter}}}_arg_to__object */

{{/body}}

{{#arg_function}}
{{> build_composite_arg_function}}

{{/arg_function}}

{{/original_arg_handling}}
{{{Interpreter.Type}}} {{{Interpreter.interpreter}}}__get_property({{{Interpreter.Type}}} thing, string property){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name =
                 jerry_create_string((const jerry_char_t *) property);
    jerry_value_t return_value = jerry_get_property(thing, prop_name);
    jerry_release_value(prop_name);
    return return_value;
} /* {{{Interpreter.interpreter}}}__get_property */
{{/body}}

void {{{Interpreter.interpreter}}}__set_property({{{Interpreter.Type}}} thing, string property, {{{Interpreter.Type}}} new_value){{#header}};{{/header}}
{{#body}}
{
   jerry_value_t prop_name =
                 jerry_create_string((const jerry_char_t *) property);
   jerry_value_t new_value_pointer = jerry_acquire_value(new_value);
   jerry_release_value(jerry_set_property(thing, prop_name, new_value_pointer));
   jerry_release_value(new_value_pointer);
   jerry_release_value(prop_name);
} /* {{{Interpreter.interpreter}}}__set_property */

{{/body}}
void Native_Object_set(void *thing, {{{Interpreter.Type}}} object, {{{Interpreter.checksum_type}}} *checksum){{#header}};{{/header}}
{{#body}}
{
    jerry_set_object_native_pointer(object, thing, checksum);
} /* Native_Object_set */

{{/body}}
void *Native_Object_get({{{Interpreter.Type}}} object,
                        {{{Interpreter.checksum_type}}} *checksum,
			jerry_error_t *error_value){{#header}};{{/header}}
{{#body}}
{
    /* points to the native object */
    void *thing = NULL;
    /* used for error checking; this value, upon return from
                        jerry_get_object_native_pointer, has to equal
                        the passed-in checksum */
    const {{{Interpreter.checksum_type}}} *stored_checksum;
    bool object_contains_native_object;

    *error_value = 0; /* when there are no errors, we want to return
    		        zero */

    object_contains_native_object = jerry_get_object_native_pointer(
                                             object, &thing, &stored_checksum);
    if (!object_contains_native_object)
        return NULL;

    if (/* TODO: JUST FOR TESTING, ALLOW THE PASSED-IN CHECKSUM TO BE NULL */
        checksum && stored_checksum != checksum)
    {
    	static const jerry_char_t *message = (jerry_char_t *)"Native Objects don't match.";
	*error_value =  jerry_create_error_sz (JERRY_ERROR_REFERENCE,
					     message,
               				     (jerry_size_t)strlen((char *)message));
	return thing; /* TODO: should we be returning "thing" in this case? */
	       	      /* ARGUABLY, yes -- let the user decide if he
        	         cares that the decallocators are different... */
    }

    return thing;
} /* Native_Object_get */
{{/body}}

char *{{{Interpreter.interpreter}}}_get_string_value({{{Interpreter.Type}}} string_value){{#header}};{{/header}}
{{#body}}
{
    int string_length = jerry_get_string_length(string_value);
    jerry_char_t *return_value = (jerry_char_t *)malloc(sizeof(jerry_char_t)*(string_length+1));

    int characters_copied = jerry_string_to_char_buffer(string_value,
                                        return_value, string_length);

    if (characters_copied != string_length)
    {
       fprintf(stderr, "PROBLEM WITH STRING COPY!\n");
       /*abort();*/
    }

    return_value[string_length]='\0';
    return (char *)return_value;
} /* jerry_get_string_value */
{{/body}}

{{! enumeration types are represented in Javascript as strings, so
    getting them across to Jerryscript and back requires some
    finagling }}
int enum_index(char *target, char **array, int array_length){{#header}};{{/header}}
{{#body}}
{
    for (int i = 0; i < array_length; i++)
        if (!strcmp(target, array[i]))
	    return i;

    /* fallthrough indicates the string's not in the array */
    return -1;
} /* enum_index */
{{/body}}


/* if the handler is NULL, then we'll assume it's a dictionary field
   rather than an interface operation, and we'll just make its default
   value undefined */
void add_field_to_object({{{Interpreter.Type}}} enclosing_object,
			    const char *function_name,
       			    jerry_external_handler_t handler){{#header}};{{/header}}
{{#body}}
{
  /* Create a JS function object and wrap into a jerry value */
  {{{Interpreter.Type}}} function_object;
  if (handler)
      function_object = jerry_create_external_function(handler);
  else
      function_object = jerry_create_undefined();

  /* Set the native function as a property of the enclosing object
     (either the global object, or a user-define object) */
  {{{Interpreter.Type}}} prop_name =
                 jerry_create_string((const jerry_char_t *) function_name);
  jerry_release_value(jerry_set_property(enclosing_object,
					 prop_name, function_object));
  jerry_release_value(prop_name);
  jerry_release_value(function_object);
} /* add_field_to_object */

{{/body}}
{{#body}}
/* for each interface, we load the operations into an
    object that we can then apply to each instance; this saves us from
    creating an object and then assigning each of the
    operations to it every time we create a new instance; the
    problem is that when they make Jerryscript multithreaded, we need
    someplace to store the prototype object that isn't in a C global
    variable -- the safest place is on the Javascript side, so we'll
    create an object here that will hold all of the interface
    prototypes as we create/use them */
{{! all of the prototype objects will hoook to this global object }}
    /* add something meaningless to the ends of the name to ensure we
       don't write over a user name */
static const char *q36 = "q36_interface_and_defintions_prototypes_holder_q36";

/* in order to keep the garbage collector from eating our prototypes
   holder, we need to maintain at least one pointer to the object, and the
   easiest place to store this is inside the prototype holder itself, so
   create a Native_Object that is nothing more than a struct that will
   hold the {{{Interpreter.Type}}} that points to the prototypes holder */
typedef struct {
    {{{Interpreter.Type}}} self;
} prototypes_holder_native_object;

/* we want to try to load the prototypes holder and then check to make
   sure that we got it, so we separate the "get" from the "check" (below) */
static {{{Interpreter.Type}}} get_prototypes_holder_helper(void)
{
    {{{Interpreter.Type}}} global_object = jerry_get_global_object();
    {{{Interpreter.Type}}} prototypes_holder_property =
                             jerry_create_string((const jerry_char_t *)q36);
    {{{Interpreter.Type}}} prototypes_holder = 
                  jerry_get_property(global_object, prototypes_holder_property);
    jerry_release_value(global_object);
    jerry_release_value(prototypes_holder_property);

    return prototypes_holder;
} /* get_prototypes_holder_helper */

/* helper function for the getter/setters, below */
static {{{Interpreter.Type}}} get_prototypes_holder(void)
{
    {{{Interpreter.Type}}} prototypes_holder = get_prototypes_holder_helper();

    /* check to see if we got the value; if not, go through the same
       code again, and if it fails again, then we've got a problem we
       can't fix */
    if (jerry_value_is_error(prototypes_holder) ||
        jerry_value_is_undefined(prototypes_holder))
    {
        create_prototypes_holder();
	prototypes_holder = get_prototypes_holder_helper();

	if (jerry_value_is_error(prototypes_holder) ||
            jerry_value_is_undefined(prototypes_holder))
    	{	    
	    fprintf(stderr, "FATAL ERROR\n");
	    exit(-1);
    	}
    }
    return prototypes_holder;
} /* get_prototypes_holder */

{{/body}}
void webidl_utilities_cleanup(void){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} prototypes_holder = get_prototypes_holder();
    jerry_error_t error_check;
    prototypes_holder_native_object *self_pointer =
                     Native_Object_get(prototypes_holder, NULL, &error_check);

    jerry_release_value(self_pointer->self);
    free(self_pointer);
    jerry_release_value(prototypes_holder);

} /* webidl_utilities_cleanup */

{{/body}}
void create_prototypes_holder(void){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} new_prototypes_holder = jerry_create_object();
    {{{Interpreter.Type}}} global_object = jerry_get_global_object();
    {{{Interpreter.Type}}} prototype_holder_name =
                                jerry_create_string((const jerry_char_t *)q36);
    /* register the new object and immediately release jerry_value */
    jerry_release_value(jerry_set_property(global_object,
	                                   prototype_holder_name,
					   new_prototypes_holder));
    jerry_release_value(prototype_holder_name);
    jerry_release_value(global_object);

    /* store a self-pointer inside the object so that it can't be GC'd */
    prototypes_holder_native_object *new_self_ptr =
                               malloc(sizeof(prototypes_holder_native_object));
    new_self_ptr->self = new_prototypes_holder;
    Native_Object_set(new_self_ptr, new_prototypes_holder, NULL);

    jerry_release_value(new_prototypes_holder);
} /* create_prototypes_holder */

{{/body}}
{{! next, we'll need a "get"ter and "set"ter for each prototype }}
{{{Interpreter.Type}}} get_prototype(char * object_name){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} prototypes_holder = get_prototypes_holder();
    {{{Interpreter.Type}}} interface_property =
                     jerry_create_string((const jerry_char_t *)object_name);
    {{{Interpreter.Type}}} prototype = jerry_get_property(prototypes_holder,
                                                  interface_property);
    jerry_release_value(prototypes_holder);
    jerry_release_value(interface_property);

    return prototype;
} /* get_prototype */

{{/body}}
void register_prototype(char * object_name, {{{Interpreter.Type}}} new_prototype){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} prototypes_holder = get_prototypes_holder();
    {{{Interpreter.Type}}} prop_name = jerry_create_string ((const jerry_char_t *) object_name);
    /* set the prototype and release the return value without any check */
    jerry_release_value(jerry_set_property (prototypes_holder,
                                            prop_name, new_prototype));
    /* clean up */
    jerry_release_value(prototypes_holder);
    jerry_release_value(prop_name);
} /* register_prototype */

{{/body}}

{{#debug_printing}}
{{#header}}
/************ DEBUG VARIABLES AND FUNCTIONS (FOR BASIC C TYPES) ***********/
/* when the indentation gets too large, it may mean that we've hit
   some infinite recursion; this value stops us at a reasonable limit */
#define DEBUG_RECURSION_DEPTH_TOO_BIG 40

/* this is, essentially, the size of a tab */
#define DEBUG_INDENTATION_WIDTH 3

#define debug_print_int8_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint8_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int16_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint16_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int32_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint32_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)


#define debug_print_byte(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_octet(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_short(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_unsignedshort(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_long(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_unsignedlong(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_longlong(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_unsignedlonglong(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_boolean(variable_name, value, indentation) \
	debug_print_bool(variable_name, (uint64_t)value, indentation)
{{/header}}

void debug_print_int64_t(char *variable_name, int64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lli\n", indentation, "", variable_name, value);
} /* debug_print_int64_t */

{{/body}}
void debug_print_uint64_t(char *variable_name, uint64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %llu\n", indentation, "", variable_name, value);
} /* debug_print_uint64_t */

{{/body}}
void debug_print_float(char *variable_name, float value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %f\n", indentation, "", variable_name, value);
} /* debug_print_float */

{{/body}}
void debug_print_double(char *variable_name, double value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lf\n", indentation, "", variable_name, value);
} /* debug_print_double */

{{/body}}
void debug_print_bool(char *variable_name, bool value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %s\n", indentation, "", variable_name, (value)?"TRUE":"FALSE");
} /* debug_print_bool */

{{/body}}
void debug_print_string(char *variable_name, char * value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  \"%s\"\n", indentation, "", variable_name, value);
} /* debug_print_string */

{{/body}}
{{#body}}
static jerry_value_t debug_evaluate_script(jerry_char_t jerry_script[])
{
    size_t jerry_script_size = strlen ((const char *) jerry_script);
    jerry_value_t eval_ret = jerry_eval (jerry_script, jerry_script_size, false);
    if (jerry_value_is_error(eval_ret))
    {
        fprintf(stderr, "ERROR parsing script!\n");
        fprintf(stderr, "\t>%s<\n", (const char *)jerry_script);
    }
    return eval_ret;
} /* debug_evaluate_script */

{{/body}}
void debug_print_message(char *message){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "debug_message_parameter");
    jerry_value_t jerry_message = jerry_create_string ((const jerry_char_t *) message);
    jerry_release_value(jerry_set_property(global_object, prop_name, jerry_message));
    jerry_char_t print_it[]="print(debug_message_parameter);";
    debug_evaluate_script(print_it);
    jerry_release_value(jerry_message);
    jerry_release_value(prop_name);
    jerry_release_value(global_object);
} /* debug_print_message */

{{/body}}
void debug_print__object(char *variable_name, float value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
	printf("%*s<object> :  \"%s\"\n", indentation, "", variable_name);
} /* debug_print__object */

{{/body}}
void debug_print_this(char *variable_name, float value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s<this pointer>\n", indentation, "");
} /* debug_print_object */

{{/body}}
void debug_print_object_fields({{{Interpreter.Type}}} thing){{#header}};{{/header}}
{{#body}}
{
    static bool first_time = true;

    if (first_time)
    {
	first_time = false;
        jerry_char_t temp[] = "var debug_print_fields =               \
 		     	       function(thing)                         \
		     	       {                                       \
				    for (var my_property in thing)     \
			    	        print(\"    \" + my_property);                  \
				};";
    	debug_evaluate_script(temp);
    }

    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "debug_print_fields_parameter");
    jerry_release_value(jerry_set_property(global_object, prop_name, thing));
    jerry_char_t print_it[]="debug_print_fields(debug_print_fields_parameter);";
    debug_evaluate_script(print_it);
    jerry_release_value(prop_name);
    jerry_release_value(global_object);
} /* debug_print_object_fields */

{{/body}}
void debug_print_any(char *variable_name, any value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    switch(value.union_type)
    {
	case boolean_uid:
	   debug_print_bool(variable_name, value.value.boolean_field, indentation);
	   break;
	case byte_uid:
	   debug_print_int8_t(variable_name, value.value.byte_field, indentation);
	case octet_uid:
	   debug_print_int8_t(variable_name, value.value.octet_field, indentation);
	   break;
	case short_uid:
	   debug_print_int16_t(variable_name, value.value.short_field, indentation);
	   break;
	case unsignedshort_uid:
	   debug_print_uint16_t(variable_name, value.value.unsignedshort_field, indentation);
	   break;
	case long_uid:
	   debug_print_int32_t(variable_name, value.value.long_field, indentation);
	   break;
	case unsignedlong_uid:
	   debug_print_uint32_t(variable_name, value.value.unsignedlong_field, indentation);
	   break;
	case longlong_uid:
	   debug_print_int64_t(variable_name, value.value.longlong_field, indentation);
	   break;
	case unsignedlonglong_uid:
	   debug_print_uint64_t(variable_name, value.value.unsignedlonglong_field, indentation);
	   break;
	case float_uid:
	   debug_print_float(variable_name, value.value.float_field, indentation);
	   break;
	case double_uid:
	   debug_print_double(variable_name, value.value.double_field, indentation);
	   break;
	case string_uid:
	   debug_print_string(variable_name, value.value.string_field, indentation);
	   break;
    }
} /* debug_print_any */

{{/body}}
void debug_print_ArrayBuffer(char *variable_name,
                             ArrayBuffer value,
                             unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    debug_print_uint32_t(variable_name, value.length, indentation);

    int data_indent = indentation + strlen(variable_name) + 3;
    int ENTRIES_PER_ROW = 8;
#define LAST_IN_ROW !((j+1)%ENTRIES_PER_ROW)
    int j = 0;
    printf("%*s", data_indent, "");
    for (j = 0; j < value.length; j++)
	printf("0x%02X%s%*s", value.data[j],
	                    (LAST_IN_ROW)?"\n":"  ",
	                    (LAST_IN_ROW && j+1 != value.length)?data_indent:0,
	                    "");

    if (j%ENTRIES_PER_ROW)
        printf("\n");
}; /* debug_print_ArrayBuffer */

{{/body}}
void debug_typeof({{{Interpreter.Type}}} thing, string thing_name){{#header}};{{/header}}
{{#body}}
{
    bool printed_at_least_one = false;

    fprintf(stdout, "%s is:\t", thing_name);
    switch(jerry_value_get_type(thing))
    {
	case JERRY_TYPE_NONE:
	    fprintf(stdout, "none\n");
	    break;
	case JERRY_TYPE_UNDEFINED:
	    fprintf(stdout, "undefined\n");
	    break;
	case JERRY_TYPE_NULL:
	    fprintf(stdout, "null\n");
	    break;
	case JERRY_TYPE_BOOLEAN:
	    fprintf(stdout, "boolean\n");
	    break;
	case JERRY_TYPE_NUMBER:
	    fprintf(stdout, "number\n");
	    break;
	case JERRY_TYPE_STRING:
	    fprintf(stdout, "string\n");
	    break;
	case JERRY_TYPE_OBJECT:
	    fprintf(stdout, "object\n");
	    break;
	case JERRY_TYPE_FUNCTION:
	    fprintf(stdout, "function\n");
	    break;
	case JERRY_TYPE_ERROR:
	    fprintf(stdout, "error\n");
	    break;
	default:
	    fprintf(stdout, "ERROR: unknown type of jerry_value_t.\n");
	    break;
    }
} /* debug_typeof */

{{/body}}
/* CAUTION: THIS FUNCTION LEAKS! */
char *debug_itoa(int x){{#header}};{{/header}}
{{#body}}
{
#define MAX_STRING_LENGTH 10
    char *return_string = malloc(sizeof(char)*MAX_STRING_LENGTH);
    snprintf(return_string, MAX_STRING_LENGTH, "%d", x);
    return return_string;
}; /* debug_itoa */

{{/body}}
/* this will give a list of all of the objects that are resident (that
   have been compiled into the interpreter) */
void debug_list_all_objects(void){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} prototypes_holder = get_prototypes_holder();
    debug_print_object_fields(prototypes_holder);
    jerry_release_value(prototypes_holder);
} /* debug_list_all_objects */

{{/body}}
{{/debug_printing}}
{{#header}}

#endif /* UTILITY_FUNCTIONS__H_ */
{{/header}}
{{/OBEYFORMATTING}}
