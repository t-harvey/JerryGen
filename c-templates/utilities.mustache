{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .c and the .h
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#header}}
#ifndef UTILITY_FUNCTIONS_H_
#define UTILITY_FUNCTIONS_H_
{{/header}}

#include <stdio.h>
#include <string.h>
#include <stdint.h>

{{#header}}
#include "jerryscript.h"
{{/header}}
{{#body}}
#include "{{{utilities_filename}}}.h"
{{/body}}

{{#header}}
typedef char * string;
typedef jerry_value_t Interpreter_Type;

/* calls to functions residing in the Javascript environment require
   extra context; from the C-programmer's point of view, callbacks
   can be thought of as _being_ this context -- for example, when
   passing around a "callback", we'll actually pass around this
   context structure, and then the generator will generate #def's
   to wrap the generic call that uses this context into an easily
   used C function */
typedef struct {
    Interpreter_Type function_value; /* Jerryscript's function pointer */
    Interpreter_Type this_value;     /* "this" pointer */
} calling_context;

{{/header}}
/* each WebIDL construct (dictionary, callback, interface, or enum)
   has a registrator function that sticks its initialization routine
   into a table of function pointers (this is before main starts --
   the registrator functions are attributed with
   __attribute(constructor)), and this is the function that runs all
   of those functions; it must be called after Jerryscript is
   initialized */
/* all of the initialization functions have a void(*)(void) signature,
   and they are stored in the following table: */
{{#header}}typedef void (*webidl_construct_initializer)(void);{{/header}}
{{#body}}
/* TODO: reason about whether all of the global, static variables in
   this file are amenable to running in a multi-threaded environment */
static int function_count = 0;
static webidl_construct_initializer *initializer_list = NULL;

{{/body}}
void register_initialization_function(webidl_construct_initializer initializer){{#header}};{{/header}}
{{#body}}
{
    static int list_size = 8;

    /* this conditional just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (initializer_list == NULL) /* first call; get some memory */
        initializer_list = malloc(sizeof(webidl_construct_initializer) *
	 		          list_size);
    else if (function_count == list_size) /* need to grow the list */
    {
        list_size *= 2;
	initializer_list = realloc(initializer_list,
		          (sizeof(webidl_construct_initializer) * list_size));
	/* TODO: check for NULL return value */
    }
    initializer_list[function_count++] = initializer;
} /* register_initialization_function */
{{/body}}
{{#header}}
typedef Interpreter_Type (*Module_Creation_Function)(void);
{{/header}}
{{#body}}

/* WebIDL constructs that have the "Return_from_require" external
   attribute set cannot be created by "new", but, rather, are the values
   returned from a call to "require" (we define that function, below); we
   store a mapping of the name given to "require" and the function that
   creates the construct, and then our "require" function will look up
   the function and dispatch it */

/* the constructs that are returned from a "require" are stored in
   this table; they map a module name with its create function */
typedef struct {
    char *function_name;
    Module_Creation_Function creator;
} Require_Table_Entry;

static int require_table_entry_count = 0;
static Require_Table_Entry *mapping_for_require;

{{/body}}
void register_require_function(string module_name,
                               Module_Creation_Function constructor_function){{#header}};{{/header}}
{{#body}}
{
    static int table_capacity = 8;

    /* this conditional just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (mapping_for_require == NULL) /* first call; get some memory */
        mapping_for_require = malloc(sizeof(Module_Creation_Function) *
	 		             table_capacity);
    else if (require_table_entry_count == table_capacity) /* need to grow the list */
    {
        table_capacity *= 2;
	mapping_for_require = realloc(mapping_for_require,
		                (sizeof(Require_Table_Entry) * table_capacity));
	/* TODO: check for NULL return value */
    }
    /* TODO: check to see if all of the module names are unique */
    mapping_for_require[require_table_entry_count++] =
                     (Require_Table_Entry){module_name, constructor_function};
} /* register_require_function */

{{/body}}
{{#body}}
/* this function provides "require" to mimic the behavior of
   node.js's "require" */
static Interpreter_Type my_require(const Interpreter_Type func_value,
             			   const Interpreter_Type this_value,
             			   const Interpreter_Type *args_p,
				   const jerry_length_t args_cnt)
{
    /* get the argument passed in */
    string module_name = interpreter_get_string_value(args_p[0]);

    /* look it up in the table */
    int target_index;
    for(target_index=0; target_index<require_table_entry_count; target_index++)
    	if (!strcmp(mapping_for_require[target_index].function_name,
	            module_name))
	    break;

    /* can't find the module? exit gracefully */
    if (target_index == require_table_entry_count)
    {
        return jerry_create_error (JERRY_ERROR_TYPE,
                             	(const jerry_char_t *) "Can't find the module");
    }

    /* call the function */
    return mapping_for_require[target_index].creator();
} /* my_require */

{{/body}}
void initialize_all_webidl_constructs(void){{#header}};{{/header}}
{{#body}}
{
    /* run all of the WebIDL constructs that have registered their respective
       initialization routines into the "initializer_list" table */
     for(int i = 0; i < function_count; i++)
        initializer_list[i]();

    /* create "require" in the global namespace */
    jerry_value_t require_function = jerry_create_external_function(my_require);
    jerry_value_t require_name =
                         jerry_create_string((const jerry_char_t *) "require");
    jerry_value_t global_object = jerry_get_global_object();
    jerry_release_value(jerry_set_property(global_object,
					   require_name, require_function));
    jerry_release_value(global_object);
    jerry_release_value(require_name);
    jerry_release_value(require_function);

} /* initialize_all_webidl_constructs */

{{/body}}
{{#header}}
/***********************IGNORE FUNCTIONS BELOW THIS LINE ****************/

/* we don't check the type of each thing while outputting code -> we
   assume that there'll be a "_create/get_thing" function for every
   type, so for the atomic types, we'll need a name mapping */
#define interpreter_get_int8_t_value (int8_t)jerry_get_number_value
#define interpreter_get_uint8_t_value (uint8_t)jerry_get_number_value
#define interpreter_get_int16_t_value (int16_t)jerry_get_number_value
#define interpreter_get_uint16_t_value (uint16_t)jerry_get_number_value
#define interpreter_get_int32_t_value (int32_t)jerry_get_number_value
#define interpreter_get_uint32_t_value (uint32_t)jerry_get_number_value
#define interpreter_get_int64_t_value (int64_t)jerry_get_number_value
#define interpreter_get_uint64_t_value (uint64_t)jerry_get_number_value
#define interpreter_get_float_value (float)jerry_get_number_value
#define interpreter_get_double_value (double)jerry_get_number_value
#define interpreter_get_bool_value (bool)jerry_get_boolean_value

/* I don't know how many of these are automatically generated -- TODO */
#define interpreter_create_array     jerry_create_array
#define interpreter_create_boolean   jerry_create_boolean
#define interpreter_create_number    jerry_create_number
#define interpreter_create_null      jerry_create_null
#define interpreter_create_string    jerry_create_string
#define interpreter_create_undefined jerry_create_undefined


#ifndef GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR
#define GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR(this_val, native_object, C_type_identifier) \
{ \
    jerry_error_t error_check; \
    native_object = Native_Object_get(this_val, &C_type_identifier, &error_check); \
    if (error_check) \
        return error_check; \
} /*GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR */
#endif

{{/header}}

void Native_Object_set(void *thing, Interpreter_Type object, jerry_object_native_info_t *checksum){{#header}};{{/header}}
{{#body}}
{
    jerry_set_object_native_pointer(object, thing, checksum);
} /* Native_Object_set */

{{/body}}
void *Native_Object_get(Interpreter_Type object,
                        jerry_object_native_info_t *checksum,
			jerry_error_t *error_value){{#header}};{{/header}}
{{#body}}
{
    /* points to the native object */
    void *thing = NULL;
    /* used for error checking; this value, upon return from
                        jerry_get_object_native_pointer, has to equal
                        the passed-in checksum */
    const jerry_object_native_info_t *stored_checksum;
    bool object_contains_native_object;

    *error_value = 0; /* when there are no errors, we want to return
    		        zero */

    object_contains_native_object = jerry_get_object_native_pointer(
                                             object, &thing, &stored_checksum);
    if (!object_contains_native_object)
        return NULL;

    if (/* JUST FOR TESTING, ALLOW THE PASSED-IN CHECKSUM TO BE NULL */
        checksum && stored_checksum != checksum)
    {
        /*fprintf(stderr, "Native Objects don't match.\n");*/
	static const jerry_char_t *message = (jerry_char_t *)"Native Objects don't match.";
	*error_value =  jerry_create_error_sz (JERRY_ERROR_REFERENCE,
					     message,
               				     (jerry_size_t)strlen((char *)message));
	return NULL; /* TODO: is this the right thing in this case? */
    }

    return thing;
} /* Native_Object_get */
{{/body}}

#include <stdlib.h>
char *interpreter_get_string_value(Interpreter_Type string_value){{#header}};{{/header}}
{{#body}}
{
    int string_length = jerry_get_string_length(string_value);
    jerry_char_t *return_value = (jerry_char_t *)malloc(sizeof(jerry_char_t)*(string_length+1));

    int characters_copied = jerry_string_to_char_buffer(string_value,
                                        return_value, string_length);

    if (characters_copied != string_length)
    {
       fprintf(stderr, "PROBLEM WITH STRING COPY!\n");
       /*abort();*/
    }

    return_value[string_length]='\0';
    return (char *)return_value;
} /* jerry_get_string_value */
{{/body}}

{{! enumeration types are represented in Javascript as strings, so
    getting them across to Jerryscript and back requires some
    finagling }}
int enum_index(char *target, char **array){{#header}};{{/header}}
{{#body}}
{
    int i = 0;
    while (array[i] != '\0')
        if (!strcmp(target, array[i]))
	    return i;
    /* fallthrough indicates the string's not in the array */
    return -1;
} /* enum_index */
{{/body}}


/* if the handler is NULL, then we'll assume it's a dictionary field
   rather than an interface operation, and we'll just make its default
   value undefined */
void add_field_to_object(Interpreter_Type enclosing_object,
			    const char *function_name,
       			    jerry_external_handler_t handler){{#header}};{{/header}}
{{#body}}
{
  /* Create a JS function object and wrap into a jerry value */
  Interpreter_Type function_object;
  if (handler)
      function_object = jerry_create_external_function(handler);
  else
      function_object = jerry_create_undefined();

  /* Set the native function as a property of the enclosing object
     (either the global object, or a user-define object) */
  Interpreter_Type prop_name =
                 jerry_create_string((const jerry_char_t *) function_name);
  jerry_release_value(jerry_set_property(enclosing_object,
					 prop_name, function_object));
  jerry_release_value(prop_name);
  jerry_release_value(function_object);
} /* add_field_to_object */

{{/body}}
{{#body}}
/* for each interface, we load the operations into an
    object that we can then apply to each instance; this saves us from
    creating an object and then assigning each of the
    operations to it every time we create a new instance; the
    problem is that when they make Jerryscript multithreaded, we need
    someplace to store the prototype object that isn't in a C global
    variable -- the safest place is on the Javascript side, so we'll
    create an object here that will hold all of the interface
    prototypes as we create/use them */
{{! all of the prototype objects will hoook to this global object }}
    /* add something meaningless to the ends of the name to ensure we
       don't write over a user name */
static const char *q36 = "q36_interface_and_defintions_prototypes_holder_q36";

/* in order to keep the garbage collector from eating our prototypes
   holder, we need to maintain at least one pointer to the object, and the
   easiest place to store this is inside the prototype holder itself, so
   create a Native_Object that is nothing more than a struct that will
   hold the Interpreter_Type that points to the prototypes holder */
typedef struct {
    Interpreter_Type self;
} prototypes_holder_native_object;

/* we want to try to load the prototypes holder and then check to make
   sure that we got it, so we separate the "get" from the "check" (below) */
static Interpreter_Type get_prototypes_holder_helper(void)
{
    Interpreter_Type global_object = jerry_get_global_object();
    Interpreter_Type prototypes_holder_property =
                             jerry_create_string((const jerry_char_t *)q36);
    Interpreter_Type prototypes_holder = 
                  jerry_get_property(global_object, prototypes_holder_property);
    jerry_release_value(global_object);
    jerry_release_value(prototypes_holder_property);

    return prototypes_holder;
} /* get_prototypes_holder_helper */

/* helper function for the getter/setters, below */
static Interpreter_Type get_prototypes_holder(void)
{
    Interpreter_Type prototypes_holder = get_prototypes_holder_helper();

    /* check to see if we got the value; if not, go through the same
       code again, and if it fails again, then we've got a problem we
       can't fix */
    if (jerry_value_has_error_flag(prototypes_holder) ||
        jerry_value_is_undefined(prototypes_holder))
    {
        create_prototypes_holder();
	prototypes_holder = get_prototypes_holder_helper();

	if (jerry_value_has_error_flag(prototypes_holder) ||
            jerry_value_is_undefined(prototypes_holder))
    	{	    
	    fprintf(stderr, "FATAL ERROR\n");
	    exit(-1);
    	}
    }
    return prototypes_holder;
} /* get_prototypes_holder */

{{/body}}
void create_prototypes_holder(){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type new_prototypes_holder = jerry_create_object();
    Interpreter_Type global_object = jerry_get_global_object();
    Interpreter_Type prototype_holder_name =
                                jerry_create_string((const jerry_char_t *)q36);
    /* register the new object and immediately release jerry_value */
    jerry_release_value(jerry_set_property(global_object,
	                                   prototype_holder_name,
					   new_prototypes_holder));
    jerry_release_value(prototype_holder_name);
    jerry_release_value(global_object);

    /* store a self-pointer inside the object so that it can't be GC'd */
    prototypes_holder_native_object *new_self_ptr =
                               malloc(sizeof(prototypes_holder_native_object));
    new_self_ptr->self = new_prototypes_holder;
    Native_Object_set(new_self_ptr, new_prototypes_holder, NULL);

    jerry_release_value(new_prototypes_holder);
} /* create_prototypes_holder */

{{/body}}
{{! next, we'll need a "get"ter and "set"ter for each prototype }}
Interpreter_Type get_prototype(char * object_name){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    Interpreter_Type interface_property =
                     jerry_create_string((const jerry_char_t *)object_name);
    Interpreter_Type prototype = jerry_get_property(prototypes_holder,
                                                  interface_property);
    jerry_release_value(prototypes_holder);
    jerry_release_value(interface_property);

    return prototype;
} /* get_prototype */

{{/body}}
void register_prototype(char * object_name, Interpreter_Type new_prototype){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    Interpreter_Type prop_name = jerry_create_string ((const jerry_char_t *) object_name);
    /* set the prototype and release the return value without any check */
    jerry_release_value(jerry_set_property (prototypes_holder,
                                            prop_name, new_prototype));
    /* clean up */
    jerry_release_value(prototypes_holder);
    jerry_release_value(prop_name);
} /* register_prototype */

{{/body}}

{{#debug_printing}}
{{#header}}
/************ DEBUG VARIABLES AND FUNCTIONS (FOR BASIC C TYPES) ***********/
/* when the indentation gets too large, it may mean that we've hit
   some infinite recursion; this value stops us at a reasonable limit */
#define DEBUG_RECURSION_DEPTH_TOO_BIG 40

/* this is, essentially, the size of a tab */
#define DEBUG_INDENTATION_WIDTH 3

#define debug_print_int8_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint8_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int16_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint16_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int32_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint32_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)
{{/header}}

void debug_print_int64_t(char *variable_name, int64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lli\n", indentation, "", variable_name, value);
} /* debug_print_int64_t */

{{/body}}
void debug_print_uint64_t(char *variable_name, uint64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %llu\n", indentation, "", variable_name, value);
} /* debug_print_uint64_t */

{{/body}}
void debug_print_float(char *variable_name, float value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %f\n", indentation, "", variable_name, value);
} /* debug_print_float */

{{/body}}
void debug_print_double(char *variable_name, double value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lf\n", indentation, "", variable_name, value);
} /* debug_print_double */

{{/body}}
void debug_print_bool(char *variable_name, bool value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %s\n", indentation, "", variable_name, (value)?"TRUE":"FALSE");
} /* debug_print_bool */
{{/body}}
void debug_print_string(char *variable_name, char * value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  \"%s\"\n", indentation, "", variable_name, value);
} /* debug_print_string */
{{/body}}
{{/debug_printing}}
{{#header}}

#endif /* UTILITY_FUNCTIONS__H_ */
{{/header}}
{{/OBEYFORMATTING}}
