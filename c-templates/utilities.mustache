{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .c and the .h
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#header}}
#ifndef UTILITY_FUNCTIONS_H_
#define UTILITY_FUNCTIONS_H_
{{/header}}

#include <stdio.h>
#include <string.h>
#include <stdint.h>

{{#header}}
#include "jerryscript.h"

{{/header}}
{{#body}}
#include "{{{utilities_filename}}}.h"

{{/body}}
{{#header}}
typedef char * string;
typedef jerry_value_t Interpreter_Type;

/* each type needs to have its own unique id (uid) so that we can
   build union types out of multiple types and differentiate between
   them; at creation of a type, we'll call this bookkeeper to give
   that type its uid */
/* since we know up front all of the WebIDL types, we'll go ahead and
   give them #defines -- this lets us use a switch statement inside of
   the interpreter_create_any function, which is a little more
   efficient */
#define boolean_uid          0
#define byte_uid             1
#define octet_uid            2
#define short_uid            3
#define unsignedshort_uid    4
#define long_uid             5
#define unsignedlong_uid     6
#define longlong_uid         7
#define unsignedlonglong_uid 8
#define float_uid            9
#define double_uid           10
#define string_uid           11
#define ArrayBuffer_uid      12
{{! any_uid MUST BE THE HIGHEST OF THESE PREDEFINED VALUES! (b/c it's used
   as the initializer for the counter in get_type_uid, below) }}
#define any_uid              13

{{/header}}
int get_type_uid(void){{#header}};{{/header}}
{{#body}}
{
    static int counter = any_uid+1;

    return counter++;
} /* get_type_uid */
{{/body}}

/* we'll give all of the atomic WebIDL types their own uids so that
   all types are treated the same way; these should be treated as
   read-only values */

/* NOTE: we only handle the above types.  Missing are: ByteString,
   USVString, Object, and Symbol. */

{{#header}}
typedef bool boolean;
typedef int8_t byte;
typedef uint8_t octet;
/*typedef int16_t short;*/
typedef uint16_t unsignedshort;
/*typedef int32_t long;*/
typedef uint32_t unsignedlong;
typedef int64_t longlong;
typedef uint64_t unsignedlonglong;
typedef float unrestricted_float;
typedef double unrestricted_double;
typedef string DOMString;
typedef string ByteString;
typedef string USVString;
typedef jerry_value_t this;

/* WebIDL's "any" type: */
typedef struct
{
    int          union_type; /* describes the type */
    union {
	bool     boolean_field;
	byte   byte_field;
	octet  octet_field;
	short short_field;
	unsignedshort unsignedshort_field;
	long  long_field;
	unsignedlong unsignedlong_field;
	longlong  longlong_field;
	unsignedlonglong unsignedlonglong_field;
	float    float_field;
	double   double_field;
	string   string_field;
    } value;
} any;
{{/header}}
/* NOTE: Jerryscript only has three types that "value" can be: string,
   boolean, or number (double) ... */
any interpreter_get_any_value(Interpreter_Type value){{#header}};{{/header}}
{{#body}}
{
    any return_value;

    if (jerry_value_is_number(value))
    {
	return_value.union_type = double_uid;
	return_value.value.double_field = jerry_get_number_value(value);
    }
    else if (jerry_value_is_boolean(value))
    {
	return_value.union_type = boolean_uid;
	return_value.value.boolean_field = jerry_get_boolean_value(value);
    }
    else if (jerry_value_is_string(value))
    {
	return_value.union_type = string_uid;
	return_value.value.string_field = interpreter_get_string_value(value);
    }
    else /* ERROR!  TODO: do something here... */
	;

    return return_value;
} /* interpreter_get_any */

{{/body}}
Interpreter_Type interpreter_create_any(any any_value){{#header}};{{/header}}
{{#body}}
{
    if (any_value.union_type == boolean_uid)
	return interpreter_create_boolean(any_value.value.boolean_field);
    else if (any_value.union_type == string_uid)
	return interpreter_create_string(
			   (const jerry_char_t *)any_value.value.string_field);
    else /* one of the number types */
    {
	switch(any_value.union_type)
	{
	    case byte_uid:
		return interpreter_create_number(any_value.value.byte_field);
	    case octet_uid:
		return interpreter_create_number(any_value.value.octet_field);
	    case short_uid:
		return interpreter_create_number(any_value.value.short_field);
	    case unsignedshort_uid:
		return interpreter_create_number(any_value.value.unsignedshort_field);
	    case long_uid:
		return interpreter_create_number(any_value.value.long_field);
	    case unsignedlong_uid:
		return interpreter_create_number(any_value.value.unsignedlong_field);
	    case longlong_uid:
		return interpreter_create_number(any_value.value.longlong_field);
	    case unsignedlonglong_uid:
		return
		    interpreter_create_number(any_value.value.unsignedlonglong_field);
	    case float_uid:
		return interpreter_create_number(any_value.value.float_field);
	    case double_uid:
		return interpreter_create_number(any_value.value.double_field);

	    default: /* ERROR!  TODO: maybe report to the user? */
		/* abort(); */
		return interpreter_create_undefined();
	}
    }
} /* interpreter_create_any */

{{/body}}
bool interpreter_value_is_any(Interpreter_Type thing_value){{#header}};{{/header}}
{{#body}}
{
    return (jerry_value_is_number(thing_value) ||
    	    jerry_value_is_boolean(thing_value) ||
    	    jerry_value_is_string(thing_value));
} /* interpreter_value_is_any */
{{/body}}

/* returns true if the Javascript object pointed to by "thing" has "name"
   as one of its fields */
bool interpreter_has_own_property(Interpreter_Type thing, string name){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name = jerry_create_string((const jerry_char_t *)name);
    jerry_value_t jerry_boolean = jerry_has_own_property(thing, prop_name);
    bool return_value = jerry_get_boolean_value(jerry_boolean);
    jerry_release_value(jerry_boolean);
    jerry_release_value(prop_name);

    return return_value;
} /* interpreter_has_own_property */

{{/body}}
/* returns true if the Javascript object pointed to by "thing" has "name"
   as one of its fields */
bool interpreter_has_property(Interpreter_Type thing, string name){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name = jerry_create_string((const jerry_char_t *)name);
    jerry_value_t jerry_boolean = jerry_has_property(thing, prop_name);
    bool return_value = jerry_get_boolean_value(jerry_boolean);

    jerry_release_value(jerry_boolean);
    jerry_release_value(prop_name);

    return return_value;
} /* interpreter_has_property */
{{/body}}

{{#header}}
/* calls to functions residing in the Javascript environment require
   extra context; from the C-programmer's point of view, callbacks
   can be thought of as _being_ this context -- for example, when
   passing around a "callback", we'll actually pass around this
   context structure, and then the generator will generate #def's
   to wrap the generic call that uses this context into an easily
   used C function */
typedef struct {
    Interpreter_Type function_value; /* Jerryscript's function pointer */
    Interpreter_Type this_value;     /* "this" pointer */
} calling_context;

{{/header}}
/* each WebIDL construct (dictionary, callback, interface, or enum)
   has a registrator function that sticks its initialization routine
   into a table of function pointers (this is before main starts --
   the registrator functions are attributed with
   __attribute(constructor)), and this is the function that runs all
   of those functions; it must be called after Jerryscript is
   initialized */
/* all of the initialization functions have a void(*)(void) signature,
   and they are stored in the following table: */
{{#header}}typedef void (*webidl_construct_initializer)(void);{{/header}}
{{#body}}
/* TODO: reason about whether all of the global, static variables in
   this file are amenable to running in a multi-threaded environment */
static int function_count = 0;
static webidl_construct_initializer *initializer_list = NULL;

{{/body}}
void register_initialization_function(webidl_construct_initializer initializer){{#header}};{{/header}}
{{#body}}
{
    static int list_size = 8;

    /* this conditional is just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (initializer_list == NULL) /* first call; get some memory */
        initializer_list = malloc(sizeof(webidl_construct_initializer) *
	 		          list_size);
    else if (function_count == list_size) /* need to grow the list */
    {
        list_size *= 2;
	initializer_list = realloc(initializer_list,
		          (sizeof(webidl_construct_initializer) * list_size));
	/* TODO: check for NULL return value */
    }
    initializer_list[function_count++] = initializer;
} /* register_initialization_function */
{{/body}}
{{#header}}
typedef Interpreter_Type (*Module_Creation_Function)(void);
{{/header}}
{{#body}}

/* WebIDL constructs that have the "ReturnFromRequire" external
   attribute set cannot be created by "new", but, rather, are the values
   returned from a call to "require" (we define that function, below); we
   store a mapping of the name given to "require" and the function that
   creates the construct, and then our "require" function will look up
   the function and dispatch it */

/* the constructs that are returned from a "require" are stored in
   this table; they map a module name with its create function */
typedef struct {
    char *function_name;
    Module_Creation_Function creator;
} Require_Table_Entry;

static int require_table_entry_count = 0;
static Require_Table_Entry *mapping_for_require;

{{/body}}
void register_require_function(string module_name,
                               Module_Creation_Function constructor_function){{#header}};{{/header}}
{{#body}}
{
    static int table_capacity = 8;

    /* this conditional is just memory management for the table that
       holds all these values -- only the last line of this routine is
       important */
    if (mapping_for_require == NULL) /* first call; get some memory */
        mapping_for_require = malloc(sizeof(Module_Creation_Function) *
	 		             table_capacity);
    else if (require_table_entry_count == table_capacity) /* need to grow the list */
    {
        table_capacity *= 2;
	mapping_for_require = realloc(mapping_for_require,
		                (sizeof(Require_Table_Entry) * table_capacity));
	/* TODO: check for NULL return value */
    }
    /* TODO: check to see if all of the module names are unique */
    mapping_for_require[require_table_entry_count++] =
                     (Require_Table_Entry){module_name, constructor_function};
} /* register_require_function */

{{/body}}
{{#body}}
/* this function provides "require" to mimic the behavior of
   node.js's "require" */
static Interpreter_Type my_require(const Interpreter_Type func_value,
             			   const Interpreter_Type this_value,
             			   const Interpreter_Type *args_p,
				   const jerry_length_t args_cnt)
{
{{! TODO: error-check parameter! }}
    /* get the argument passed in */
    string module_name = interpreter_get_string_value(args_p[0]);

    /* look it up in the table */
    int target_index;
    for(target_index=0; target_index<require_table_entry_count; target_index++)
    	if (!strcmp(mapping_for_require[target_index].function_name,
	            module_name))
	    break;

    /* can't find the module? exit gracefully */
    if (target_index == require_table_entry_count)
    {
{{! TODO: add the name of the module to the error message }}
        return jerry_create_error (JERRY_ERROR_TYPE,
                             	(const jerry_char_t *) "Can't find the module");
    }

    /* call the function */
    return mapping_for_require[target_index].creator();
} /* my_require */

{{/body}}
void initialize_all_webidl_constructs(void){{#header}};{{/header}}
{{#body}}
{
    /* run all of the WebIDL constructs that have registered their respective
       initialization routines into the "initializer_list" table */
     for(int i = 0; i < function_count; i++)
        initializer_list[i](); /* each entry is a function pointer, so
				  with the "()", these are calls */

    /* create "require" in the global namespace */
    jerry_value_t require_function = jerry_create_external_function(my_require);
    jerry_value_t require_name =
                         jerry_create_string((const jerry_char_t *) "require");
    jerry_value_t global_object = jerry_get_global_object();
    jerry_release_value(jerry_set_property(global_object,
					   require_name, require_function));
    jerry_release_value(global_object);
    jerry_release_value(require_name);
    jerry_release_value(require_function);

} /* initialize_all_webidl_constructs */

{{/body}}
{{#header}}
/***********************IGNORE FUNCTIONS BELOW THIS LINE ****************/

/* we don't check the type of each thing while outputting code -> we
   assume that there'll be a "_create/get_thing/is_of_type" function for
   every type, so for the atomic types, we'll need a name mapping */
// #define interpreter_get_int8_t_value (int8_t)jerry_get_number_value
// #define interpreter_get_uint8_t_value (uint8_t)jerry_get_number_value
// #define interpreter_get_int16_t_value (int16_t)jerry_get_number_value
// #define interpreter_get_uint16_t_value (uint16_t)jerry_get_number_value
// #define interpreter_get_int32_t_value (int32_t)jerry_get_number_value
// #define interpreter_get_uint32_t_value (uint32_t)jerry_get_number_value
// #define interpreter_get_int64_t_value (int64_t)jerry_get_number_value
// #define interpreter_get_uint64_t_value (uint64_t)jerry_get_number_value
// #define interpreter_get_float_value (float)jerry_get_number_value
// #define interpreter_get_double_value (double)jerry_get_number_value
// #define interpreter_get_bool_value (bool)jerry_get_boolean_value

#define interpreter_get_byte_value (byte)jerry_get_number_value
#define interpreter_get_octet_value (octet)jerry_get_number_value
#define interpreter_get_short_value (short)jerry_get_number_value
#define interpreter_get_unsignedshort_value (unsignedshort)jerry_get_number_value
#define interpreter_get_long_value (long)jerry_get_number_value
#define interpreter_get_unsignedlong_value (unsignedlong)jerry_get_number_value
#define interpreter_get_longlong_value (longlong)jerry_get_number_value
#define interpreter_get_unsignedlonglong_value (unsignedlonglong)jerry_get_number_value
#define interpreter_get_boolean_value (boolean)jerry_get_boolean_value

/* we check value types using their C-type names, although the checks
   translate into checking for synonymous Javascript types */
// #define interpreter_value_is_int8_t (bool)jerry_value_is_number
// #define interpreter_value_is_uint8_t (bool)jerry_value_is_number
// #define interpreter_value_is_int16_t (bool)jerry_value_is_number
// #define interpreter_value_is_uint16_t (bool)jerry_value_is_number
// #define interpreter_value_is_int32_t (bool)jerry_value_is_number
// #define interpreter_value_is_uint32_t (bool)jerry_value_is_number
// #define interpreter_value_is_int64_t (bool)jerry_value_is_number
// #define interpreter_value_is_uint64_t (bool)jerry_value_is_number
// #define interpreter_value_is_float (bool)jerry_value_is_number
#define interpreter_value_is_double (bool)jerry_value_is_number
// #define interpreter_value_is_bool (bool)jerry_value_is_boolean
#define interpreter_value_is_string (bool)jerry_value_is_string

#define interpreter_value_is_byte (bool)jerry_value_is_number
#define interpreter_value_is_octet (bool)jerry_value_is_number
#define interpreter_value_is_short (bool)jerry_value_is_number
#define interpreter_value_is_unsignedshort (bool)jerry_value_is_number
#define interpreter_value_is_long (bool)jerry_value_is_number
#define interpreter_value_is_unsignedlong (bool)jerry_value_is_number
#define interpreter_value_is_longlong (bool)jerry_value_is_number
#define interpreter_value_is_unsignedlonglong (bool)jerry_value_is_number
#define interpreter_value_is_boolean (bool)jerry_value_is_boolean

#define interpreter_value_is_number (bool)jerry_value_is_number

/* I don't know how many of these are automatically generated -- TODO */
#define interpreter_create_array     jerry_create_array
#define interpreter_create_boolean   jerry_create_boolean
#define interpreter_create_number    jerry_create_number
#define interpreter_create_null      jerry_create_null
#define interpreter_create_string    jerry_create_string
#define interpreter_create_undefined jerry_create_undefined

#define interpreter_create_byte (bool)jerry_create_number
#define interpreter_create_octet (bool)jerry_create_number
#define interpreter_create_short (bool)jerry_create_number
#define interpreter_create_unsignedshort (bool)jerry_create_number
#define interpreter_create_long (bool)jerry_create_number
#define interpreter_create_unsignedlong (bool)jerry_create_number
#define interpreter_create_longlong (bool)jerry_create_number
#define interpreter_create_unsignedlonglong (bool)jerry_create_number


#ifndef GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR
#define GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR(this_val, native_object, C_type_identifier) \
{ \
    jerry_error_t error_check; \
    native_object = Native_Object_get(this_val, &C_type_identifier, &error_check); \
    if (error_check) \
        return error_check; \
} /*GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR */
#endif

{{/header}}

Interpreter_Type interpreter_get_property(Interpreter_Type thing, string property){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t prop_name =
                 jerry_create_string((const jerry_char_t *) property);
    jerry_value_t return_value = jerry_get_property(thing, prop_name);
    jerry_release_value(prop_name);
    return return_value;
} /* interpreter_get_property */
{{/body}}

void Native_Object_set(void *thing, Interpreter_Type object, jerry_object_native_info_t *checksum){{#header}};{{/header}}
{{#body}}
{
    jerry_set_object_native_pointer(object, thing, checksum);
} /* Native_Object_set */

{{/body}}
void *Native_Object_get(Interpreter_Type object,
                        jerry_object_native_info_t *checksum,
			jerry_error_t *error_value){{#header}};{{/header}}
{{#body}}
{
    /* points to the native object */
    void *thing = NULL;
    /* used for error checking; this value, upon return from
                        jerry_get_object_native_pointer, has to equal
                        the passed-in checksum */
    const jerry_object_native_info_t *stored_checksum;
    bool object_contains_native_object;

    *error_value = 0; /* when there are no errors, we want to return
    		        zero */

    object_contains_native_object = jerry_get_object_native_pointer(
                                             object, &thing, &stored_checksum);
    if (!object_contains_native_object)
        return NULL;

    if (/* JUST FOR TESTING, ALLOW THE PASSED-IN CHECKSUM TO BE NULL */
        checksum && stored_checksum != checksum)
    {
        /*fprintf(stderr, "Native Objects don't match.\n");*/
	static const jerry_char_t *message = (jerry_char_t *)"Native Objects don't match.";
	*error_value =  jerry_create_error_sz (JERRY_ERROR_REFERENCE,
					     message,
               				     (jerry_size_t)strlen((char *)message));
	return NULL; /* TODO: is this the right thing in this case? */
    }

    return thing;
} /* Native_Object_get */
{{/body}}

#include <stdlib.h>
char *interpreter_get_string_value(Interpreter_Type string_value){{#header}};{{/header}}
{{#body}}
{
    int string_length = jerry_get_string_length(string_value);
    jerry_char_t *return_value = (jerry_char_t *)malloc(sizeof(jerry_char_t)*(string_length+1));

    int characters_copied = jerry_string_to_char_buffer(string_value,
                                        return_value, string_length);

    if (characters_copied != string_length)
    {
       fprintf(stderr, "PROBLEM WITH STRING COPY!\n");
       /*abort();*/
    }

    return_value[string_length]='\0';
    return (char *)return_value;
} /* jerry_get_string_value */
{{/body}}

{{! enumeration types are represented in Javascript as strings, so
    getting them across to Jerryscript and back requires some
    finagling }}
int enum_index(char *target, char **array, int array_length){{#header}};{{/header}}
{{#body}}
{
    for (int i = 0; i < array_length; i++)
        if (!strcmp(target, array[i]))
	    return i;

    /* fallthrough indicates the string's not in the array */
    return -1;
} /* enum_index */
{{/body}}


/* if the handler is NULL, then we'll assume it's a dictionary field
   rather than an interface operation, and we'll just make its default
   value undefined */
void add_field_to_object(Interpreter_Type enclosing_object,
			    const char *function_name,
       			    jerry_external_handler_t handler){{#header}};{{/header}}
{{#body}}
{
  /* Create a JS function object and wrap into a jerry value */
  Interpreter_Type function_object;
  if (handler)
      function_object = jerry_create_external_function(handler);
  else
      function_object = jerry_create_undefined();

  /* Set the native function as a property of the enclosing object
     (either the global object, or a user-define object) */
  Interpreter_Type prop_name =
                 jerry_create_string((const jerry_char_t *) function_name);
  jerry_release_value(jerry_set_property(enclosing_object,
					 prop_name, function_object));
  jerry_release_value(prop_name);
  jerry_release_value(function_object);
} /* add_field_to_object */

{{/body}}
{{#body}}
/* for each interface, we load the operations into an
    object that we can then apply to each instance; this saves us from
    creating an object and then assigning each of the
    operations to it every time we create a new instance; the
    problem is that when they make Jerryscript multithreaded, we need
    someplace to store the prototype object that isn't in a C global
    variable -- the safest place is on the Javascript side, so we'll
    create an object here that will hold all of the interface
    prototypes as we create/use them */
{{! all of the prototype objects will hoook to this global object }}
    /* add something meaningless to the ends of the name to ensure we
       don't write over a user name */
static const char *q36 = "q36_interface_and_defintions_prototypes_holder_q36";

/* in order to keep the garbage collector from eating our prototypes
   holder, we need to maintain at least one pointer to the object, and the
   easiest place to store this is inside the prototype holder itself, so
   create a Native_Object that is nothing more than a struct that will
   hold the Interpreter_Type that points to the prototypes holder */
typedef struct {
    Interpreter_Type self;
} prototypes_holder_native_object;

/* we want to try to load the prototypes holder and then check to make
   sure that we got it, so we separate the "get" from the "check" (below) */
static Interpreter_Type get_prototypes_holder_helper(void)
{
    Interpreter_Type global_object = jerry_get_global_object();
    Interpreter_Type prototypes_holder_property =
                             jerry_create_string((const jerry_char_t *)q36);
    Interpreter_Type prototypes_holder = 
                  jerry_get_property(global_object, prototypes_holder_property);
    jerry_release_value(global_object);
    jerry_release_value(prototypes_holder_property);

    return prototypes_holder;
} /* get_prototypes_holder_helper */

/* helper function for the getter/setters, below */
static Interpreter_Type get_prototypes_holder(void)
{
    Interpreter_Type prototypes_holder = get_prototypes_holder_helper();

    /* check to see if we got the value; if not, go through the same
       code again, and if it fails again, then we've got a problem we
       can't fix */
    if (jerry_value_has_error_flag(prototypes_holder) ||
        jerry_value_is_undefined(prototypes_holder))
    {
        create_prototypes_holder();
	prototypes_holder = get_prototypes_holder_helper();

	if (jerry_value_has_error_flag(prototypes_holder) ||
            jerry_value_is_undefined(prototypes_holder))
    	{	    
	    fprintf(stderr, "FATAL ERROR\n");
	    exit(-1);
    	}
    }
    return prototypes_holder;
} /* get_prototypes_holder */

{{/body}}
void webidl_utilities_cleanup(void){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    jerry_error_t error_check;
    prototypes_holder_native_object *self_pointer =
                     Native_Object_get(prototypes_holder, NULL, &error_check);

    jerry_release_value(self_pointer->self);
    free(self_pointer);
    jerry_release_value(prototypes_holder);

} /* webidl_utilities_cleanup */

{{/body}}
void create_prototypes_holder(void){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type new_prototypes_holder = jerry_create_object();
    Interpreter_Type global_object = jerry_get_global_object();
    Interpreter_Type prototype_holder_name =
                                jerry_create_string((const jerry_char_t *)q36);
    /* register the new object and immediately release jerry_value */
    jerry_release_value(jerry_set_property(global_object,
	                                   prototype_holder_name,
					   new_prototypes_holder));
    jerry_release_value(prototype_holder_name);
    jerry_release_value(global_object);

    /* store a self-pointer inside the object so that it can't be GC'd */
    prototypes_holder_native_object *new_self_ptr =
                               malloc(sizeof(prototypes_holder_native_object));
    new_self_ptr->self = new_prototypes_holder;
    Native_Object_set(new_self_ptr, new_prototypes_holder, NULL);

    jerry_release_value(new_prototypes_holder);
} /* create_prototypes_holder */

{{/body}}
{{! next, we'll need a "get"ter and "set"ter for each prototype }}
Interpreter_Type get_prototype(char * object_name){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    Interpreter_Type interface_property =
                     jerry_create_string((const jerry_char_t *)object_name);
    Interpreter_Type prototype = jerry_get_property(prototypes_holder,
                                                  interface_property);
    jerry_release_value(prototypes_holder);
    jerry_release_value(interface_property);

    return prototype;
} /* get_prototype */

{{/body}}
void register_prototype(char * object_name, Interpreter_Type new_prototype){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    Interpreter_Type prop_name = jerry_create_string ((const jerry_char_t *) object_name);
    /* set the prototype and release the return value without any check */
    jerry_release_value(jerry_set_property (prototypes_holder,
                                            prop_name, new_prototype));
    /* clean up */
    jerry_release_value(prototypes_holder);
    jerry_release_value(prop_name);
} /* register_prototype */

{{/body}}

{{#debug_printing}}
{{#header}}
/************ DEBUG VARIABLES AND FUNCTIONS (FOR BASIC C TYPES) ***********/
/* when the indentation gets too large, it may mean that we've hit
   some infinite recursion; this value stops us at a reasonable limit */
#define DEBUG_RECURSION_DEPTH_TOO_BIG 40

/* this is, essentially, the size of a tab */
#define DEBUG_INDENTATION_WIDTH 3

#define debug_print_int8_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint8_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int16_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint16_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_int32_t(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_uint32_t(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)


#define debug_print_byte(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_octet(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_short(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_unsignedshort(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_long(variable_name, value, indentation) \
	debug_print_int64_t(variable_name, (int64_t)value, indentation)

#define debug_print_unsignedlong(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_unsignedlonglong(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_unsignedlonglong(variable_name, value, indentation) \
	debug_print_uint64_t(variable_name, (uint64_t)value, indentation)

#define debug_print_boolean(variable_name, value, indentation) \
	debug_print_bool(variable_name, (uint64_t)value, indentation)
{{/header}}

void debug_print_int64_t(char *variable_name, int64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lli\n", indentation, "", variable_name, value);
} /* debug_print_int64_t */

{{/body}}
void debug_print_uint64_t(char *variable_name, uint64_t value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %llu\n", indentation, "", variable_name, value);
} /* debug_print_uint64_t */

{{/body}}
void debug_print_float(char *variable_name, float value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %f\n", indentation, "", variable_name, value);
} /* debug_print_float */

{{/body}}
void debug_print_double(char *variable_name, double value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %lf\n", indentation, "", variable_name, value);
} /* debug_print_double */

{{/body}}
void debug_print_bool(char *variable_name, bool value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  %s\n", indentation, "", variable_name, (value)?"TRUE":"FALSE");
} /* debug_print_bool */
{{/body}}
void debug_print_string(char *variable_name, char * value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    printf("%*s%s :  \"%s\"\n", indentation, "", variable_name, value);
} /* debug_print_string */
{{/body}}
{{#body}}
static jerry_value_t debug_evaluate_script(jerry_char_t jerry_script[])
{
    size_t jerry_script_size = strlen ((const char *) jerry_script);
    jerry_value_t eval_ret = jerry_eval (jerry_script, jerry_script_size, false);
    if (jerry_value_has_error_flag (eval_ret))
    {
        fprintf(stderr, "ERROR parsing script!\n");
        fprintf(stderr, "\t>%s<\n", (const char *)jerry_script);
    }
    return eval_ret;
} /* debug_evaluate_script */
{{/body}}
void debug_print_message(char *message){{#header}};{{/header}}
{{#body}}
{
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "debug_message_parameter");
    jerry_value_t jerry_message = jerry_create_string ((const jerry_char_t *) message);
    jerry_release_value(jerry_set_property(global_object, prop_name, jerry_message));
    jerry_char_t print_it[]="print(debug_message_parameter);";
    debug_evaluate_script(print_it);
    jerry_release_value(jerry_message);
    jerry_release_value(prop_name);
    jerry_release_value(global_object);
} /* debug_print_message */
{{/body}}
void debug_print_object_fields(Interpreter_Type thing){{#header}};{{/header}}
{{#body}}
{
    static bool first_time = true;

    if (first_time)
    {
	first_time = false;
        jerry_char_t temp[] = "var debug_print_fields =               \
 		     	       function(thing)                         \
		     	       {                                       \
				    for (var my_property in thing)     \
			    	        print(\"    \" + my_property);                  \
				};";
    	debug_evaluate_script(temp);
    }

    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "debug_print_fields_parameter");
    jerry_release_value(jerry_set_property(global_object, prop_name, thing));
    jerry_char_t print_it[]="debug_print_fields(debug_print_fields_parameter);";
    debug_evaluate_script(print_it);
    jerry_release_value(prop_name);
    jerry_release_value(global_object);
} /* debug_print_object_fields */
{{/body}}
void debug_print_any(char *variable_name, any value, unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    switch(value.union_type)
    {
	case boolean_uid:
	   debug_print_bool(variable_name, value.value.boolean_field, indentation);
	   break;
	case byte_uid:
	   debug_print_int8_t(variable_name, value.value.byte_field, indentation);
	case octet_uid:
	   debug_print_int8_t(variable_name, value.value.octet_field, indentation);
	   break;
	case short_uid:
	   debug_print_int16_t(variable_name, value.value.short_field, indentation);
	   break;
	case unsignedshort_uid:
	   debug_print_uint16_t(variable_name, value.value.unsignedshort_field, indentation);
	   break;
	case long_uid:
	   debug_print_int32_t(variable_name, value.value.long_field, indentation);
	   break;
	case unsignedlong_uid:
	   debug_print_uint32_t(variable_name, value.value.unsignedlong_field, indentation);
	   break;
	case longlong_uid:
	   debug_print_int64_t(variable_name, value.value.longlong_field, indentation);
	   break;
	case unsignedlonglong_uid:
	   debug_print_uint64_t(variable_name, value.value.unsignedlonglong_field, indentation);
	   break;
	case float_uid:
	   debug_print_float(variable_name, value.value.float_field, indentation);
	   break;
	case double_uid:
	   debug_print_double(variable_name, value.value.double_field, indentation);
	   break;
	case string_uid:
	   debug_print_string(variable_name, value.value.string_field, indentation);
	   break;
    }
} /* debug_print_any */
{{/body}}

void debug_typeof(Interpreter_Type thing, string thing_name){{#header}};{{/header}}
{{#body}}
{
    bool printed_at_least_one = false;

    fprintf(stdout, "%s is:\t", thing_name);
    switch(jerry_value_get_type(thing))
    {
	case JERRY_TYPE_NONE:
	    fprintf(stdout, "none\n");
	    break;
	case JERRY_TYPE_UNDEFINED:
	    fprintf(stdout, "undefined\n");
	    break;
	case JERRY_TYPE_NULL:
	    fprintf(stdout, "null\n");
	    break;
	case JERRY_TYPE_BOOLEAN:
	    fprintf(stdout, "boolean\n");
	    break;
	case JERRY_TYPE_NUMBER:
	    fprintf(stdout, "number\n");
	    break;
	case JERRY_TYPE_STRING:
	    fprintf(stdout, "string\n");
	    break;
	case JERRY_TYPE_OBJECT:
	    fprintf(stdout, "object\n");
	    break;
	case JERRY_TYPE_FUNCTION:
	    fprintf(stdout, "function\n");
	    break;
    }
} /* debug_typeof */

{{/body}}
/* CAUTION: THIS FUNCTION LEAKS! */
char *debug_itoa(int x){{#header}};{{/header}}
{{#body}}
{
#define MAX_STRING_LENGTH 10
    char *return_string = malloc(sizeof(char)*MAX_STRING_LENGTH);
    snprintf(return_string, MAX_STRING_LENGTH, "%d", x);
    return return_string;
}; /* debug_itoa */

{{/body}}
/* this will give a list of all of the objects that are resident (that
   have been compiled into the interpreter) */
void debug_list_all_objects(void){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type prototypes_holder = get_prototypes_holder();
    debug_print_object_fields(prototypes_holder);
    jerry_release_value(prototypes_holder);
} /* debug_list_all_objects */
{{/body}}
{{/debug_printing}}
{{#header}}

#endif /* UTILITY_FUNCTIONS__H_ */
{{/header}}
{{/OBEYFORMATTING}}
