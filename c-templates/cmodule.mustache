{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jerryscript.h"
#include "{{{moduleName}}}_Types.h"

{{#interfaces}}
/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by Jerryscript, and
   Jerryscript also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, Jerryscript
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free) */
typedef struct {
{{#repress_stubs}}
       /* USER CODE GOES HERE */
{{/repress_stubs}}
{{^repress_stubs}}
	/* DEFINED IN THE STUBS FILE */
{{/repress_stubs}}
} Native_Object_{{{interfaceName}}};

{{#repress_stubs}}
static void Native_Object_{{{interfaceName}}}_deallocator(void *native_object)
{
	/* USER CODE GOES HERE */
} /* Native_Object_{{{interfaceName}}}_deallocator */

static Native_Object_{{{interfaceName}}} *Native_Object_{{{interfaceName}}}_create(void)
{
    Native_Object_{{{interfaceName}}} *new_object = (Native_Object_{{{interfaceName}}} *)malloc(sizeof(Native_Object_{{{interfaceName}}}));

	/* USER CODE GOES HERE */ 
    return new_object;
} /* Native_Object_{{{interfaceName}}}_create */
{{/repress_stubs}}
{{^repress_stubs}}
extern void Native_Object_{{{interfaceName}}}_deallocator(void *native_object);
extern Native_Object_{{{interfaceName}}}* Native_Object_{{{interfaceName}}}_create(void);
{{/repress_stubs}}
{{! the checksum is used by Jerryscript to ensure that the
    Native_Object is still valid; when we make the stubs, we need to
    set up the checksum here, but also give it to the stubs file }}
{{#repress_stubs}}static{{/repress_stubs}}{{^repress_stubs}}extern{{/repress_stubs}}
jerry_object_native_info_t {{{interfaceName}}}_checksum{{^repress_stubs}};{{/repress_stubs}}{{#repress_stubs}} = {Native_Object_{{{interfaceName}}}_deallocator};{{/repress_stubs}}
{{/interfaces}}

{{! I DON'T THINK THIS IS NECESSARY... }}
{{#interfaces}}
{{^NoInterfaceObject}}
jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt);
{{/NoInterfaceObject}}
{{/interfaces}}

/* put all of the native-code functions (indentifable by the
 *  suffix "_handler") here: */

{{#interfaces}}
    {{#operations}}
static jerry_value_t
{{{name}}}_handler(const jerry_value_t func_value, /**< function object */
		   const jerry_value_t this_val, /**< this arg */
                   const jerry_value_t *args_p, /**< function arguments */
                   const jerry_length_t args_cnt) /**< number of function arguments */
{
    /* demarshal the arguments{{#repress_stubs}} and setup the Native_Object{{/repress_stubs}} */
{{! TODO: the "this_val" passed in to a function parameter: should it be
    this_val, or should we gen up a value_t for the global object? }}
    {{#arguments}}
        {{#variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}_Array {{{name}}} = jerry_get_array_of_{{{C_Type}}}(args_p, args_cnt, {{{paramIndex}}});
   	     {{/C_and_Jerryscript_Types}}
        {{/variadic}}
        {{^variadic}}
   	     {{#C_and_Jerryscript_Types}}
	     {{#callback}}
    {{{C_Type}}}_calling_context{{#is_array}}_Array{{/is_array}} {{{name}}}{{#repress_stubs}}_context{{/repress_stubs}} = ({{{C_Type}}}_calling_context){args_p[{{{paramIndex}}}], this_val};
{{#repress_stubs}}#define {{{name}}}(...) (run_{{{C_Type}}}_function({{{name}}}_context, __VA_ARGS__)){{/repress_stubs}}
	     {{/callback}}
	     {{^callback}}
    {{{C_Type}}}{{#is_array}}_Array{{/is_array}} {{{name}}} = jerry_get_{{^is_array}}{{{C_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}_value(args_p[{{{paramIndex}}}]);
	     {{/callback}}
             {{/C_and_Jerryscript_Types}}	
        {{/variadic}}
    {{/arguments}}
{{#repress_stubs}}
    Native_Object_{{{interfaceName}}} *native_object;
    GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR(this_val, native_object, {{{interfaceName}}}_checksum);

    /* USER CODE GOES HERE */

{{/repress_stubs}}
{{^repress_stubs}}
{{#C_and_Jerryscript_Types}}
extern {{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{/return_is_this}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}jerry_value_t);
{{/C_and_Jerryscript_Types}}
{{/repress_stubs}}
{{! for the "return_value", the logic is as follows: 1) don't put out
the declaration if it's a void return type or this function returns
the this pointer; 2) if we're repressing stubs, then put it out as a
simple declaration; 3) if we're not repressing stubs, then put out the
declaration with an assignment from the stub }}
{{#repress_stubs}}{{^voidReturnType}}
/* THIS VARIABLE SHOULD HOLD THE VALUE TO BE RETURNED */{{/voidReturnType}}{{/repress_stubs}}
{{#C_and_Jerryscript_Types}}
{{^voidReturnType}}{{^return_is_this}}    {{{C_Type}}}{{#is_array}}_Array{{/is_array}} return_value{{#repress_stubs}};{{/repress_stubs}}{{^repress_stubs}} ={{/repress_stubs}}{{/return_is_this}}{{/voidReturnType}}{{^repress_stubs}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}this_val);{{/repress_stubs}}
{{/C_and_Jerryscript_Types}}
    {{! if the return value is a string (or array of strings), we want
        to enter it into the Jerryscript environment _before_ we
        deallocate our local strings, as it's possible that the return
        value is just a copy of one of args }}
    {{#C_and_Jerryscript_Types}}
        {{#is_string}}
    {{! DOES THE FOLLOWING COVER ALL OF THE PERMUTATIONS? }}
    /* put the string into Jerryscript before we cleanup any string arguments */
    jerry_value_t string_value = jerry_create_string{{#is_array}}_Array{{/is_array}}({{^is_array}}(const jerry_char_t *){{/is_array}}return_value);
        {{/is_string}}
    {{/C_and_Jerryscript_Types}}
    {{! FREE MALLOC'D STRINGS}}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	    {{^callback}}
	        {{#is_string}}
		{{^is_array}}
    if ({{{name}}} != NULL) free({{{name}}});
		{{/is_array}}
       		{{/is_string}}
    	    {{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
{{! ^repress_stubs}}
    {{#C_and_Jerryscript_Types}}
        {{#return_is_this}}
    /* return a reference back to this interface */
    return this_val;
        {{/return_is_this}}
        {{^return_is_this}}
            {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
            {{/voidReturnType}}
            {{^voidReturnType}}
                {{^is_string}}
    return jerry_create_{{^is_array}}{{{Jerryscript_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}(return_value);
                {{/is_string}}
                {{#is_string}}
     return string_value;
                {{/is_string}}
            {{/voidReturnType}}
        {{/return_is_this}}
    {{/C_and_Jerryscript_Types}}
{{! /repress_stubs}}
} /* {{{name}}}_handler */


    {{/operations}}
{{/interfaces}}


/* we define types here, and marshalling/demarshalling methods of each type. */
static void load_types_into_Jerryscript_environment()
{
    static bool already_called = false;

    if (already_called) return;
    else already_called = true;

{{#dictionaries}}
    /* Create a JS object */
    const jerry_char_t my_js_object_{{{name}}}[] = " \
        function {{{name}}}({{#members}}{{{name}}}_parm{{^finalMember}},{{/finalMember}}{{/members}}) \
        { \
            {{#members}}
            this.{{{name}}} = {{{name}}}_parm; \
            {{/members}}
	    {{#C_type_list.length}}
	    this._what_kind_am_I = {{{name}}}; \ {{! name of object }}
	    {{/C_type_list.length}}
        }; \
      ";
    jerry_value_t my_js_obj_val_{{{name}}};

    /* Evaluate script */
    my_js_obj_val_{{{name}}} = jerry_eval (my_js_object_{{{name}}},
                              strlen ((const char *) my_js_object_{{{name}}}),
                              false);
    jerry_release_value(my_js_obj_val_{{{name}}});
{{/dictionaries}}
} /* load_types_into_Jerryscript_environment */

{{#interfaces}}
/* external declaration in {{{moduleName}}}_Types.h */
jerry_value_t
create_{{{interfaceName}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt)
{
{{! If the object has been specified as no-interface, then the user's
    not allowed to create a new one of these; for now, return the
    (single) global object instead of an error }}
{{#NoInterfaceObject}}
    jerry_value_t object_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t object = jerry_get_property(global_object, object_name);
    jerry_release_value(object_name);
    jerry_release_value(global_object);
    return object;
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    jerry_value_t new_{{{interfaceName}}} = jerry_create_object();

    {{#attributes}}
    if ((((signed int)args_cnt)-1) >= {{{attribute_index}}})
    {
        jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
        jerry_set_property(new_{{{interfaceName}}}, {{{name}}}_prop_name, args_p[{{{attribute_index}}}]);
        jerry_release_value({{{name}}}_prop_name);
    }

    {{/attributes}}
    jerry_value_t prototype = get_prototype((char *)"{{{interfaceName}}}");
    jerry_set_prototype(new_{{{interfaceName}}}, prototype);
    jerry_release_value(prototype);

    /* setup the Native_Object for the new object */
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_{{{interfaceName}}}_create();
    Native_Object_set(native_object, new_{{{interfaceName}}}, &{{{interfaceName}}}_checksum);

    return new_{{{interfaceName}}};
{{/NoInterfaceObject}}
} /* create_{{{name}}}_interface_handler */
{{/interfaces}}


{{#interfaces}}
void load_{{{interfaceName}}}_interface(void)
{
    load_types_into_Jerryscript_environment();

    {{! for attributes: attributes cannot get a default value, which
       means that they don't need to be created now; Javascript
       automagically creates them when they're first defined, so we
       don't need to do anything -- we probably don't need to do
       anything in the object version of the interface, either, but it
       looks nice... }}
    {{! IS THE ABOVE STILL TRUE?  WHAT IF IT'S A NOINTERFACEOBJECT? }}

    jerry_value_t global_object = jerry_get_global_object();

    /* add all of the interface prototypes */
    jerry_value_t {{{name}}}_prototype_object = jerry_create_object();
    {{#operations}}
    register_function_call({{{interfaceName}}}_prototype_object,
                           "{{{name}}}", &{{{name}}}_handler);
    {{/operations}}

{{! if it's specified as a NoInterfaceObject, then the object goes
    into the global namespace; otherwise, the object is used as a
    prototype, so record in the global prototypes holder }}
{{#NoInterfaceObject}}
    /* setup the Native_Object for the new object */
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_{{{interfaceName}}}_create();
    Native_Object_set(native_object, {{{name}}}_prototype_object, &{{{interfaceName}}}_checksum);

    jerry_value_t object_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t throwaway = jerry_set_property(global_object,
						object_name,
						{{{name}}}_prototype_object);
    jerry_release_value(throwaway);
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    register_prototype((char *)"{{{name}}}", {{{name}}}_prototype_object);
{{/NoInterfaceObject}}
    jerry_release_value({{{name}}}_prototype_object);

{{^NoInterfaceObject}}
{{! this sets up the ability to "new" the object, if it's not been specified
    as NoInterface }}
    register_function_call(global_object, "{{{name}}}", &create_{{{name}}}_interface_handler);

{{/NoInterfaceObject}}
    jerry_release_value(global_object);

} /* load_{{{name}}}_interface */
{{/interfaces}}

{{/OBEYFORMATTING}}
