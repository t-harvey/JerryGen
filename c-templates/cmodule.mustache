{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(!) be in the input file }}
{{^OBEYFORMATTING}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jerryscript.h"
#include "{{{moduleName}}}_Types.h"

{{! I DON'T THINK THIS IS NECESSARY... }}
{{#interfaces}}
{{^NoInterfaceObject}}
jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt);
{{/NoInterfaceObject}}
{{/interfaces}}

// put all of the native-code functions (indentifable by the
// suffix "_handler") here:

{{#interfaces}}
    {{#operations}}
static jerry_value_t
{{{name}}}_handler(const jerry_value_t func_value, /**< function object */
		   const jerry_value_t this_val, /**< this arg */
                   const jerry_value_t *args_p, /**< function arguments */
                   const jerry_length_t args_cnt) /**< number of function arguments */
{
    // demarshal the arguments
{{! TODO: the "this_val" passed in to a function parameter: should it be
    this_val, or should we gen up a value_t for the global object? }}
    {{#arguments}}
        {{#variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}_Array {{{name}}} = jerry_get_array_of_{{{C_Type}}}(args_p, args_cnt, {{{paramIndex}}});
   	     {{/C_and_Jerryscript_Types}}
        {{/variadic}}
        {{^variadic}}
   	     {{#C_and_Jerryscript_Types}}
	     {{#callback}}
    {{{C_Type}}}_calling_context{{#is_array}}_Array{{/is_array}} {{{name}}} = ({{{C_Type}}}_calling_context){args_p[{{{paramIndex}}}], this_val};
	     {{/callback}}
	     {{^callback}}
    {{{C_Type}}}{{#is_array}}_Array{{/is_array}} {{{name}}} = jerry_get_{{^is_array}}{{{C_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}_value(args_p[{{{paramIndex}}}]);
	     {{/callback}}
             {{/C_and_Jerryscript_Types}}	
        {{/variadic}}
    {{/arguments}}

{{#repress_stubs}}
// USER CODE GOES HERE
{{/repress_stubs}}
{{^repress_stubs}}
{{#C_and_Jerryscript_Types}}
extern {{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{/return_is_this}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#hasAttributes}}{{#arguments.length}}, {{/arguments.length}}jerry_value_t{{/hasAttributes}});

    {{^voidReturnType}}{{^return_is_this}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}} return_value{{#is_string}}_string{{/is_string}} ={{/return_is_this}}{{/voidReturnType}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#hasAttributes}}{{#arguments.length}}, {{/arguments.length}}this_val{{/hasAttributes}});
{{#is_string}}
    jerry_value_t return_value = jerry_create_string{{#is_array}}_Array{{/is_array}}({{^is_array}}(const jerry_char_t *){{/is_array}}return_value_string);
{{/is_string}}
{{/C_and_Jerryscript_Types}}

{{/repress_stubs}}
{{#repress_stubs}}
    {{! FREE MALLOC'D STRINGS}}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	    {{^callback}}
	        {{#is_string}}
		{{^is_array}}
    if ({{{name}}} != NULL) free({{{name}}});
		{{/is_array}}
       		{{/is_string}}
    	    {{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}

{{/repress_stubs}}
{{^repress_stubs}}
    {{#C_and_Jerryscript_Types}}
        {{#return_is_this}}
    /* return a reference back to this interface */
    return this_val;
        {{/return_is_this}}
        {{^return_is_this}}
            {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
            {{/voidReturnType}}
            {{^voidReturnType}}
                {{^is_string}}
    return jerry_create_{{^is_array}}{{{Jerryscript_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}(return_value);
                {{/is_string}}
                {{#is_string}}
     return return_value;
                {{/is_string}}
            {{/voidReturnType}}
        {{/return_is_this}}
    {{/C_and_Jerryscript_Types}}

{{/repress_stubs}}
} /* {{{name}}}_handler */
/*
 *
 */
    {{/operations}}
{{/interfaces}}


// we define types here, and marshalling/demarshalling methods of each type.
static void load_types_into_Jerryscript_environment()
{
    static bool already_called = false;

    if (already_called) return;
    else already_called = true;

{{#dictionaries}}
    /* Create a JS object */
    const jerry_char_t my_js_object_{{{name}}}[] = " \
        function {{{name}}}({{#members}}{{{name}}}_parm{{^finalMember}},{{/finalMember}}{{/members}}) \
        { \
            {{#members}}
            this.{{{name}}} = {{{name}}}_parm; \
            {{/members}}
	    {{#C_type_list.length}}
	    this._what_kind_am_I = {{{name}}}; \ {{! name of object }}
	    {{/C_type_list.length}}
        }; \
      ";
    jerry_value_t my_js_obj_val_{{{name}}};

    /* Evaluate script */
    my_js_obj_val_{{{name}}} = jerry_eval (my_js_object_{{{name}}},
                              strlen ((const char *) my_js_object_{{{name}}}),
                              false);
    jerry_release_value(my_js_obj_val_{{{name}}});
{{/dictionaries}}
} /* load_types_into_Jerryscript_environment */

{{#interfaces}}
/* external declaration in {{{moduleName}}}_Types.h */
jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt)
{
{{! If the object has been specified as no-interface, then the user's
    not allowed to create a new one of these; for now, return the
    (single) global object instead of an error }}
{{#NoInterfaceObject}}
    jerry_value_t object_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t global_object = jerry_get_global_object();
    jerry_value_t object = jerry_get_property(global_object, object_name);
    jerry_release_value(object_name);
    jerry_release_value(global_object);
    return object;
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    jerry_value_t new_{{{interfaceName}}} = jerry_create_object();

    {{#attributes}}
    if ((((signed int)args_cnt)-1) >= {{{attribute_index}}})
    {
        jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
        jerry_set_property(new_{{{interfaceName}}}, {{{name}}}_prop_name, args_p[{{{attribute_index}}}]);
        jerry_release_value({{{name}}}_prop_name);
    }
    {{/attributes}}

    jerry_value_t prototype = get_prototype((char *)"{{{interfaceName}}}");
    jerry_set_prototype(new_{{{interfaceName}}}, prototype);
    jerry_release_value(prototype);

    return new_{{{interfaceName}}};
{{/NoInterfaceObject}}
} /* create_{{{name}}}_interface_handler */
{{/interfaces}}


{{#interfaces}}
void load_{{{name}}}_interface(void)
{
    load_types_into_Jerryscript_environment();

    {{! for attributes: attributes cannot get a default value, which
       means that they don't need to be created now; Javascript
       automagically creates them when they're first defined, so we
       don't need to do anything -- we probably don't need to do
       anything in the object version of the interface, either, but it
       looks nice... }}
    {{! IS THE ABOVE STILL TRUE?  WHAT IF IT'S A NOINTERFACEOBJECT? }}

    jerry_value_t global_object = jerry_get_global_object();

    /* add all of the interface prototypes */
    jerry_value_t {{{name}}}_prototype_object = jerry_create_object();
    {{#operations}}
    register_function_call({{{interfaceName}}}_prototype_object,
                           "{{{name}}}", &{{{name}}}_handler);
    {{/operations}}

{{! if it's specified as a NoInterfaceObject, then the object goes
    into the global namespace; otherwise, the object is used as a
    prototype, so record in the global prototypes holder }}
{{#NoInterfaceObject}}
    jerry_value_t object_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t throwaway = jerry_set_property(global_object,
						object_name,
						{{{name}}}_prototype_object);
    jerry_release_value(throwaway);
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    register_prototype((char *)"{{{name}}}", {{{name}}}_prototype_object);
{{/NoInterfaceObject}}
    jerry_release_value({{{name}}}_prototype_object);

{{^NoInterfaceObject}}
{{! this sets up the ability to "new" the object, if it's not been specified
    as NoInterface }}
    register_function_call(global_object, "{{{name}}}", &create_{{{name}}}_interface_handler);

{{/NoInterfaceObject}}
    jerry_release_value(global_object);

} /* load_{{{name}}}_interface */
{{/interfaces}}

{{/OBEYFORMATTING}}
