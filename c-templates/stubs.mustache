{{! we surround everything in a "{{#" construct that can't possibly be
    existent so that all of the (vertical) whitespace gets translated
    to the output file }}
{{^OBEYFORMATTING}}
{{#interfaces}}
/*# AUTOMATICALLY GENERATED ON {{timestamp}} #*/
{{#header}}
#ifndef {{{interfaceName}}}_STUBS_HEADER_FILE
#define {{{interfaceName}}}_STUBS_HEADER_FILE 1
#include "{{{utilities_filename}}}.h"
#include "{{{interfaceName}}}.h"
{{/header}}
{{#body}}
#include "{{{interfaceName}}}_stubs.h"
{{/body}}
{{#debug_printing}}
#include <stdio.h>
{{/debug_printing}}

{{#header}}
{{#externalTypes}}
#include "{{{package}}}/{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}

/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by Jerryscript, and
   Jerryscript also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, Jerryscript
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free) */
typedef struct {
    /* USER CODE GOES HERE */
} Native_Object_{{{interfaceName}}};

{{/header}}
{{#body}}
{{#debug_printing}}
#define DEBUG_PRINTING 1

{{/debug_printing}}
{{^debug_printing}}
#undef DEBUG_PRINTING
{{/debug_printing}}
{{/body}}
{{#body}}
#include "{{{interfaceName}}}_stubs.h"

static jerry_error_t error_check; /* examine this if the value of native_object
    		  	             might be wrong after a call to
				     Native_Object_get() */

/*********************** NATIVE-OBJECT FUNCTIONS ***********************/

{{/body}}
void Native_Object_{{{interfaceName}}}_deallocator(void *native_object){{#header}};{{/header}}
{{#body}}
{
	/* USER CODE GOES HERE */

} /* Native_Object_{{{interfaceName}}}_deallocator */

{{/body}}
Native_Object_{{{interfaceName}}} *Native_Object_{{{interfaceName}}}_create(void){{#header}};{{/header}}
{{#body}}
{
    Native_Object_{{{interfaceName}}} *new_object = (Native_Object_{{{interfaceName}}} *)malloc(sizeof(Native_Object_{{{interfaceName}}}));

	/* USER CODE GOES HERE */
 
    return new_object;
} /* Native_Object_{{{interfaceName}}}_create */

{{/body}}
{{! the checksum is used by Jerryscript to ensure that the
    Native_Object is still valid; note that this has a global linkage,
    since the support routines need this value }}
{{#header}}/* this should never be touched by the user */{{/header}}
{{#header}}extern {{/header}}jerry_object_native_info_t {{{interfaceName}}}_checksum{{#body}} = {Native_Object_{{{interfaceName}}}_deallocator}{{/body}};
{{#body}}

/******************* END OF NATIVE-OBJECT FUNCTIONS *******************/
{{/body}}

/* {{{interfaceName}}} */
{{#is_module}}
/* this gets us the definition of the {{{interfaceName}}} type */
#include "{{{interfaceName}}}.h"
{{{interfaceName}}} require_{{{interfaceName}}}_body(void){{#header}};{{/header}}
{{#body}}
{
    {{{interfaceName}}} return_value;

    /* set up "return_value" */
    /* USER CODE GOES HERE */

    return return_value;
} /* require_{{{interfaceName}}}_body */

{{/body}}
{{/is_module}}
{{#operations}}
{{#C_and_Jerryscript_Types}}{{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{{C_Type}}}{{/return_is_this}}{{/C_and_Jerryscript_Types}} {{{interfaceName}}}_{{{operationName}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}} {{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}Interpreter_Type this_val){{#header}};{{/header}}
{{#body}}
{
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
#define {{{name}}}(...) (run_{{{C_Type}}}_function({{{name}}}_context, __VA_ARGS__))
	{{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
    /* EXAMINE THE VALUE OF "ERROR_CHECK" IF THERE COULD BE AN ERROR
       WITH AN OBJECT'S Native_Object */    
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_get(this_val, &{{{interfaceName}}}_checksum, &error_check);

{{#debug_printing}}
#ifdef DEBUG_PRINTING
{{#arguments.length}}
   printf("PARAMETERS TO \"{{{operationName}}}\" :\n");
 {{#arguments}}
	{{! TODO: VARIADIC AND ARRAY PARAMETER PRINTING! }}
        {{^variadic}}{{^is_array}}
   	     {{#C_and_Jerryscript_Types}}
    debug_print_{{{C_Type}}}("{{{name}}}", {{{name}}}, DEBUG_INDENTATION_WIDTH);
             {{/C_and_Jerryscript_Types}}	
        {{/is_array}}{{/variadic}}
 {{/arguments}}
{{/arguments.length}}
{{^arguments.length}}
   printf("\tThe function \"{{{operationName}}}\" takes no parameters.\n");
{{/arguments.length}}
#endif /* DEBUG_PRINTING */

{{/debug_printing}}
    /* USER CODE GOES HERE */

{{#debug_printing}}
{{#C_and_Jerryscript_Types}}
{{^voidReturnType}}
{{#return_is_this}} {{! CAN A STUB EVER RETURN "this"?!? -- NO; IT'S A
		        VOID RETURN TYPE... }}
    /*return this_val;*/
{{/return_is_this}}
{{^return_is_this}}
#ifdef DEBUG_PRINTING
    /* CAUTION: this is undefined; it is used to allow us to compile the code
       without warnings */
    {{{C_and_Jerryscript_Types.C_Type}}} undefined_return_value;
    return undefined_return_value;
#endif /* DEBUG_PRINTING */
{{/return_is_this}}
{{/voidReturnType}}
{{/C_and_Jerryscript_Types}}
{{/debug_printing}}
    {{! we need to undo the #defines for callbacks }}

    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
#undef {{{name}}}
	{{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
}; /* {{{interfaceName}}}_{{{operationName}}}_body */

{{/body}}
{{/operations}}
{{#header}}

#endif /* {{{interfaceName}}}_STUBS_HEADER_FILE */
{{/header}}
{{/interfaces}}
{{/OBEYFORMATTING}}
