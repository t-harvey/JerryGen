{{! we surround everything in a "{{#" construct that can't possibly be
    existent so that all of the (vertical) whitespace gets translated
    to the output file }}
{{^OBEYFORMATTING}}
/*# AUTOMATICALLY GENERATED ON {{timestamp}} #*/
#include "{{{moduleName}}}_Types.h"
{{#interfaces}}
/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by Jerryscript, and
   Jerryscript also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, Jerryscript
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free) */
typedef struct {
       // USER CODE GOES HERE

} Native_Object_{{{interfaceName}}};

static void Native_Object_{{{interfaceName}}}_deallocator(void *native_object)
{
	// USER CODE GOES HERE

} /* Native_Object_{{{interfaceName}}}_deallocator */

Native_Object_{{{interfaceName}}} *Native_Object_{{{interfaceName}}}_create(void)
{
    Native_Object_{{{interfaceName}}} *new_object = (Native_Object_{{{interfaceName}}} *)malloc(sizeof(Native_Object_{{{interfaceName}}}));

	// USER CODE GOES HERE
 
    return new_object;
} /* Native_Object_{{{interfaceName}}}_create */

{{! the checksum is used by Jerryscript to ensure that the
    Native_Object is still valid; note that this has a global linkage,
    since the support routines need this value }}
jerry_object_native_info_t {{{interfaceName}}}_checksum = {Native_Object_{{{interfaceName}}}_deallocator};

/* {{{interfaceName}}} */
{{#operations}}
{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{/C_and_Jerryscript_Types}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}} {{{name}}}{{#C_and_Jerryscript_Types}}{{#callback}}_context{{/callback}}{{/C_and_Jerryscript_Types}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}jerry_value_t this_val)
{
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
#define {{{name}}}(...) (run_{{{C_Type}}}_function({{{name}}}_context, __VA_ARGS__))
	{{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_get(this_val, &{{{interfaceName}}}_checksum);

    // USER CODE GOES HERE

    {{! do we need to undo the #defines for callbacks? }}
}; /* {{{interfaceName}}}_{{{name}}}_body */


{{/operations}}
{{/interfaces}}
{{/OBEYFORMATTING}}

