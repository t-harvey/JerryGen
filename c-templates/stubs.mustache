{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! we surround everything in a "{{#" construct that can't possibly be
    existent so that all of the (vertical) whitespace gets translated
    to the output file }}
{{^OBEYFORMATTING}}
{{#interfaces}}
{{#print_generation_message}}
/*# AUTOMATICALLY GENERATED ON {{timestamp}} #*/
{{/print_generation_message}}
{{#header}}
#ifndef {{{interfaceName}}}_STUBS_HEADER_FILE
#define {{{interfaceName}}}_STUBS_HEADER_FILE 1
#include "{{{utilities_filename}}}.h"
#include "{{{interfaceName}}}.h"
{{/header}}
{{#body}}
#include "{{{utilities_filename}}}.h"
#include "{{{interfaceName}}}.h"
#include "{{{interfaceName}}}_stubs.h"
{{/body}}

{{#header}}
{{#externalTypes}}
#include "{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}

{{#inheritance}}
/* because the {{{interfaceName}}} inherits from the {{{inheritance}}}
   interface, the Native Object for both of these interfaces has to be
   the same -- the definition of the {{{inheritance}}}_Native_Object
   is in the {{{inheritance}}}_stubs.h file */
#define {{{interfaceName}}}_Native_Object {{{inheritance}}}_Native_Object
{{/inheritance}}
{{^inheritance}}
/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by the interpreter, and
   the interpreter also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, the interpreter
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free) */
typedef struct {
    /* USER CODE GOES HERE */

} {{{interfaceName}}}_Native_Object;

{{/inheritance}}
{{/header}}
{{#body}}
{{#debug_printing}}
#define DEBUG_PRINTING 1

{{/debug_printing}}
{{^debug_printing}}
#undef DEBUG_PRINTING
{{/debug_printing}}
{{/body}}
{{#body}}
#include "{{{interfaceName}}}_stubs.h"

/*********************** NATIVE-OBJECT FUNCTIONS ***********************/

{{/body}}
{{#inheritance}}
  {{#body}}
/* because the {{{interfaceName}}} inherits from the {{{inheritance}}}
   interface, the Native Object for both of these interfaces has to be
   the same -- the definition of the {{{inheritance}}}_Native_Object is in the
   {{{inheritance}}}_stubs.h file */
  {{/body}}
  {{#header}}
#define {{{interfaceName}}}_Native_Object_deallocator {{{inheritance}}}_Native_Object_deallocator
#define {{{interfaceName}}}_Native_Object_create {{{inheritance}}}_Native_Object_create
  {{/header}}
{{/inheritance}}
{{^inheritance}}
void {{{interfaceName}}}_Native_Object_deallocator(void *native_object){{#header}};{{/header}}
{{#body}}
{
	/* USER CODE GOES HERE */

} /* {{{interfaceName}}}_Native_Object_deallocator */

{{/body}}
{{{interfaceName}}}_Native_Object *{{{interfaceName}}}_Native_Object_create(void){{#header}};{{/header}}
{{#body}}
{
    {{{interfaceName}}}_Native_Object *new_object = ({{{interfaceName}}}_Native_Object *)malloc(sizeof({{{interfaceName}}}_Native_Object));

	/* USER CODE GOES HERE */
 
    return new_object;
} /* {{{interfaceName}}}_Native_Object_create */
{{/body}}
{{/inheritance}}
{{#body}}

/******************* END OF NATIVE-OBJECT FUNCTIONS *******************/
{{/body}}

/* {{{interfaceName}}} */
{{#is_module}}
{{#body}}
/**
 * this is the initialization routine for a "require"'d type (that
 * is, a module)
 */
{{/body}}
{{{interfaceName}}} require_{{{interfaceName}}}(void){{#header}};{{/header}}
{{#body}}
{
    /* the {{{interface}}}_constructor creates a new {{{interfaceName}}
       filled in with default values */
    {{{interfaceName}}} return_value = {{{interfaceName}}}_constructor();

    /* set up "return_value" */
    /* USER CODE GOES HERE */

    return return_value;
} /* require_{{{interfaceName}}} */

{{/body}}
{{/is_module}}
{{#operations}}
{{#body}}
/**
 *
 */ 
{{/body}}
{{#C_and_Jerryscript_Types}}{{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{{C_Type}}}{{/return_is_this}}{{/C_and_Jerryscript_Types}} {{{interfaceName}}}_{{{operationName}}}({{{Interpreter.Type}}} *self{{#arguments.length}}, {{/arguments.length}}{{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{/C_and_Jerryscript_Types}} {{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}){{#header}};{{/header}}
{{#body}}
{
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
	{{{C_Type}}} _temp__for_{{{name}}} = {{{name}}};
#define {{{name}}}(...) (run_{{{C_Type}}}_function(_temp__for_{{{name}}}, *self, __VA_ARGS__))
	{{/callback}}
        {{/C_and_Jerryscript_Types}}

    {{/arguments}}
    {{{Interpreter.error_type}}} error_check;
    {{{interfaceName}}}_Native_Object *native_object = {{{interfaceName}}}_Native_Object_get(*self, &error_check);
    if (error_check)
    {
        *self = error_check;
	{{#C_and_Jerryscript_Types}}
	{{^voidReturnType}}{{^return_is_this}}/* we return a (meaningless) default value here so the compiler doesn't complain */{{/return_is_this}}{{/voidReturnType}}
	return{{^voidReturnType}}{{^return_is_this}} {{{default_value}}}{{/return_is_this}}{{/voidReturnType}};
	{{/C_and_Jerryscript_Types}}
    }

{{#debug_printing}}
#ifdef DEBUG_PRINTING
   printf("PARAMETERS TO \"{{{operationName}}}\" :\n");
{{#arguments.length}}
 {{#arguments}}
   {{#C_and_Jerryscript_Types}}
    debug_print_{{{C_Type}}}("{{{name}}}", {{{name}}}, DEBUG_INDENTATION_WIDTH);
   {{/C_and_Jerryscript_Types}}	
 {{/arguments}}
{{/arguments.length}}
{{^arguments.length}}
   printf("\tThe function \"{{{operationName}}}\" takes no parameters.\n");
{{/arguments.length}}
#endif /* DEBUG_PRINTING */

{{/debug_printing}}
    /* USER CODE GOES HERE */

{{#debug_printing}}
{{#C_and_Jerryscript_Types}}
{{^voidReturnType}}
{{#return_is_this}} {{! CAN A STUB EVER RETURN "this"?!? -- NO; IT'S A
		        VOID RETURN TYPE... }}
    /*return self;*/
{{/return_is_this}}
{{^return_is_this}}
#ifdef DEBUG_PRINTING
    /* CAUTION: this is undefined; it is used to allow us to compile the code
       without warnings */
    {{#C_and_Jerryscript_Types}}
    {{{C_Type}}} undefined_return_value = {{{default_value}}};
    debug_print_{{{C_Type}}}("RETURN_VALUE", undefined_return_value, 0);
    return undefined_return_value;
    {{/C_and_Jerryscript_Types}}
#endif /* DEBUG_PRINTING */
{{/return_is_this}}
{{/voidReturnType}}
{{/C_and_Jerryscript_Types}}
{{/debug_printing}}
    {{! we need to undo the #defines for callbacks }}

    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
#undef {{{name}}}
	{{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
}; /* {{{interfaceName}}}_{{{operationName}}} */

{{/body}}
{{/operations}}
{{#header}}

#endif /* {{{interfaceName}}}_STUBS_HEADER_FILE */
{{/header}}
{{/interfaces}}
{{/OBEYFORMATTING}}
