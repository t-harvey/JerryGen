{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .h and the .c
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#enums}}
{{#header}}
#ifndef {{{enumName}}}_ENUM_H_
#define {{{enumName}}}_ENUM_H_
{{/header}}

#include <stdio.h>
#include <string.h>
#include "{{{utilities_filename}}}.h"
{{#body}}
#include "{{{enumName}}}.h"

{{/body}}
/* this variable is used in composite types to denote a field of type
   {{{interfaceName}}} -- this should be considered a read-only value */
{{#header}}extern {{/header}}int {{{enumName}}}_uid;

{{#header}}
#include "jerryscript.h"
typedef enum { {{#members}}{{{indentation}}}{{{name}}}{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} }{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}} {{/onlyOneMember}}{{{enumName}}};
{{/header}}
{{#body}}
static int number_of_{{{enumName}}} = {{{members.length}}};
{{/body}}
{{#header}}

/********************* IGNORE FUNCTIONS BELOW THIS LINE *********************/

{{/header}}
{{! TODO: what if the "members" list is empty?!?"}}
/* all WebIDL constructs have a constructor function, so that C code
   can build any of these constructs -- for enums, just return the
   first symbol in the list */
{{{enumName}}} {{{enumName}}}_constructor(void){{#header}};{{/header}}
{{#body}}
{
    return {{{members.0.name}}};
} /* {{{enumName}}}_constructor */
{{/body}}

{{! we first need strings that match the enumeration values }}
{{#body}}
static char *{{{enumName}}}_strings[] = { {{#members}}{{{indentation}}}{{{indentation}}}[{{{name}}}] = "{{{name}}}"{{^finalMember}},{{{new_line}}}{{/finalMember}}{{#onlyOneMember}} };{{/onlyOneMember}}{{/members}}
{{^onlyOneMember}}};{{/onlyOneMember}}

{{/body}}
{{{enumName}}} interpreter_get_{{{enumName}}}_value(Interpreter_Type value){{#header}};{{/header}}
{{#body}}
{
{{! TODO: check that enum_index doesn't return -1! }}
    return ({{{enumName}}})enum_index(interpreter_get_string_value(value), {{{enumName}}}_strings, number_of_{{{enumName}}});
} /* interpreter_get_{{{enumName}}}_value */
{{/body}}

Interpreter_Type interpreter_create_{{{enumName}}}({{{enumName}}} x){{#header}};{{/header}}
{{#body}}
{
    return interpreter_create_string ((const jerry_char_t *) {{{enumName}}}_strings[x]);
} /* interpreter_create_{{{enumName}}} */

{{/body}}
bool interpreter_value_is_{{{enumName}}}(Interpreter_Type thing_value){{#header}};{{/header}}
{{#body}}
{
    if (!jerry_value_is_string(thing_value))
        return false;
    else
    {
        char *enum_string = interpreter_get_string_value(thing_value);

        {{! TODO: this is gross -- use a (perfect)hash, maybe? }}
        for (int i = 0; i < number_of_{{{enumName}}}; i++)
            if (!strcmp({{{enumName}}}_strings[i], enum_string))
                return true;
    }

    /* fall-through indicates we didn't find the name in this enumeration */
    return false;
} /* interpreter_value_is_{{{enumName}}} */

{{/body}}
{{! the following greatly(!) simplifies the code elsewhere, b/c we
    assume every type has this function, even though enums don't need to
    do anything }}
{{#header}}
/* this can be ignored; it simplifies the definition of interfaces
   that include this type... */
#define initialize_{{{enumName}}}_()
{{/header}}
{{#debug_printing}}

void debug_print_{{{enumName}}} (char *variable_name,
                                      {{{enumName}}} value,
                                      unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    if (value < 0 || value >= number_of_{{{enumName}}})
    	printf("%*s%s: the value passed in is not a valid {{{enumName}}} value\n",
                                      indentation, "", variable_name);
    else
        printf("%*s%s: %s\n", indentation, "", variable_name, {{{enumName}}}_strings[value]);
} /* debug_print_{{{enumName}}} */
{{/body}}
{{/debug_printing}}

{{#body}}
/* every type needs a uid (supplied by webidl_utilities), so set it up here */
__attribute__((constructor))
static void register_{{{enumName}}}_uid(void)
{
    {{{enumName}}}_uid = get_type_uid();
} /* register_{{{enumName}}}_uid */
{{/body}}
{{#header}}

#endif /* {{{enumName}}}_ENUM_H_ */
{{/header}}
{{/enums}}
{{/OBEYFORMATTING}}
