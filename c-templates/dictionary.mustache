{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .h and the .c
    *_Types files -- look for the "body" and "header" markers }}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{#dictionaries}}
{{#header}}
#ifndef {{{dictionaryName}}}_H_
#define {{{dictionaryName}}}_H_
{{/header}}

/* these are included to simplify the generator. Remove if not needed.*/
/* #include <string> */
/* #include <vector> */
#include <stdio.h>
#include <string.h>
#include "jerryscript.h"

{{#header}}
{{#externalTypes}}
#include "{{! REMOVING AS A TEST: brace brace brace package brace brace brace/}}{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}
#include "{{{utilities_filename}}}.h"
{{/header}}
{{#body}}
#include "{{{dictionaryName}}}.h"
{{/body}}

/* this variable is used in composite types to denote a field of type
   {{{interfaceName}}} -- this should be considered a read-only value */
{{#header}}extern {{/header}}int {{{dictionaryName}}}_uid;

{{#header}}
typedef struct {
	{{#members}}
    {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}{{#is_array_object}}{{#is_array}} *{{/is_array}}{{/is_array_object}} {{{memberName}}};
    {{/C_and_Jerryscript_Types}}
	{{/members}}
} {{{dictionaryName}}};
{{/header}}
{{#header}}

/********************* IGNORE FUNCTIONS BELOW THIS LINE *********************/

{{/header}}
/* all WebIDL constructs have a constructor function, so that C code
   can build any of these constructs */
{{{dictionaryName}}} {{{dictionaryName}}}_constructor(void){{#header}};{{/header}}
{{#body}}
{
    {{{dictionaryName}}} new_{{{dictionaryName}}};
    {{#is_array_object}}
    new_{{{dictionaryName}}}.length = 0;
    new_{{{dictionaryName}}}.items = NULL;
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    {{! the "get_default_value" function takes the string and either
    	returns the default value for the C_Type if its an intrinsic
        type or "<C_Type>_constructor()" (for WebIDL constructs) }}

    {{#C_and_Jerryscript_Types}}
    new_{{{dictionaryName}}}.{{{memberName}}} = {{{default_value}}};
    {{/C_and_Jerryscript_Types}}
    {{/members}}
    {{/is_array_object}}

    return new_{{{dictionaryName}}};
} /* {{{dictionaryName}}}_constructor */
{{/body}}

{{! really, these functions should be named "get_..._struct" rather
    than "get_..._value" -- but b/c Jerryscript already has get_*_value
    for all of the builtin types, it's easier to follow that naming
    scheme for dictionaries and interfaces...}}
{{{dictionaryName}}} interpreter_get_{{{dictionaryName}}}_value(Interpreter_Type value){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type object_value = jerry_value_to_object(value);
    {{{dictionaryName}}} return_struct;

    {{#is_array_object}}
    {
	unsigned int array_length = jerry_get_array_length(value);
    {{#members}}
    {{#C_and_Jerryscript_Types}}
    {{^is_array}}
	return_struct.length = array_length;
    {{/is_array}}
    {{#is_array}}
    return_struct.items = ({{{C_Type}}} *)malloc(sizeof({{{C_Type}}})*array_length);
    for(int i = 0; i < array_length; i++)
        return_struct.items[i] = ({{{C_Type}}})interpreter_get_{{{C_Type}}}_value(jerry_get_property_by_index(value, i));
    {{/is_array}}
    {{/C_and_Jerryscript_Types}}
    {{/members}}
    }
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    Interpreter_Type {{{memberName}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{memberName}}}");
    Interpreter_Type {{{memberName}}}_value = jerry_get_property(object_value, {{{memberName}}}_prop_name);
    {{#C_and_Jerryscript_Types}}
    return_struct.{{{memberName}}} = ({{{C_Type}}})interpreter_get_{{{C_Type}}}_value({{{memberName}}}_value);
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{memberName}}}_prop_name);
    jerry_release_value({{{memberName}}}_value);

    {{/members}}
    {{/is_array_object}}

    jerry_release_value(object_value);

    return return_struct;
} /* interpreter_get_{{{dictionaryName}}}_value */

{{/body}}

/* like all the interpreter_create_* functions, this one takes a C
   variable and creates its Jerryscript/Javascript equivalent */
Interpreter_Type interpreter_create_{{{dictionaryName}}}({{{dictionaryName}}} x){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type new_jerry_value = jerry_create_object();

    {{#is_array_object}}
    {{#members}}
    {{#C_and_Jerryscript_Types}}
    {{#is_array}}
    for (int i = 0; i < x.length; i++)
    {
        Interpreter_Type next = interpreter_create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}(x.items[i]));
    	jerry_release_value(jerry_set_property_by_index(new_jerry_value, i, next));
    	jerry_release_value(next);
    }
    {{/is_array}}
    {{/C_and_Jerryscript_Types}}
    {{/members}}
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    Interpreter_Type {{{memberName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{memberName}}}");
    {{#C_and_Jerryscript_Types}}
    Interpreter_Type {{{memberName}}}_value = interpreter_create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}x.{{{memberName}}});
    {{/C_and_Jerryscript_Types}}
    jerry_release_value(jerry_set_property(new_jerry_value, {{{memberName}}}_prop_name, {{{memberName}}}_value));
    jerry_release_value({{{memberName}}}_value);
    jerry_release_value({{{memberName}}}_prop_name);

    {{/members}}
    {{/is_array_object}}

    return new_jerry_value;
    
} /* interpreter_create_{{{dictionaryName}}} */

{{/body}}

bool interpreter_value_is_{{{dictionaryName}}}(Interpreter_Type thing_value){{#header}};{{/header}}
{{#body}}
{
    {{#is_array_object}}
    if (!jerry_value_is_array(thing_value))
        return false;
    else
    {
        if (jerry_get_array_length(thing_value) == 0)
	    return true;
	else
	{
	{{! TODO: maybe check every element? }}
	{{#members}}
	{{#C_and_Jerryscript_Types}}
	{{#is_array}}
	    jerry_value_t first_element =
	                          jerry_get_property_by_index(thing_value, 0);
	    bool is_target_value = interpreter_value_is_{{{C_and_Jerryscript_Types.C_Type}}}(first_element);
	    jerry_release_value(first_element);

	    return is_target_value;
	{{/is_array}}
	{{/C_and_Jerryscript_Types}}
	{{/members}}
	}
    }        
    {{/is_array_object}}
    {{^is_array_object}}
    /* it's perfectly legal for a dictionary to be built without using
       "new", in which case, checking its type won't give us the
       actual dictionary type we're looking for -- it'll just give us
       "object"; instead, we'll walk through an object's fields and,
       	if they're all there and of the right type, then we'll return true */
{{#members}}
        if (!interpreter_has_own_property(thing_value,
                                          "{{{memberName}}}"))
            return false;
        else
        {
{{#C_and_Jerryscript_Types}}
            Interpreter_Type field = interpreter_get_property(thing_value,
                                                            "{{{memberName}}}");
	    bool value_is_right_type = interpreter_value_is_{{{C_Type}}}(field);
            jerry_release_value(field);

            if (!value_is_right_type)
                return false;
{{/C_and_Jerryscript_Types}}
        }
{{/members}}

    /* fall-through indicates that we have an object of this type */
    return true;
    {{/is_array_object}}
} /* interpreter_value_is_{{{dictionaryName}}} */
{{/body}}

{{#body}}
static Interpreter_Type
create_{{{dictionaryName}}}_dictionary_handler(const Interpreter_Type func_value,
                   const Interpreter_Type this_val,
                   const Interpreter_Type *args_p,
                   const jerry_length_t args_cnt)
{
    Interpreter_Type new_{{{dictionaryName}}} = jerry_create_object();
    Interpreter_Type prototype = get_prototype((char *) "{{{dictionaryName}}}");
    jerry_release_value(jerry_set_prototype(new_{{{dictionaryName}}}, prototype));
    jerry_release_value(prototype);

    {{#members}}
    {
        Interpreter_Type {{{memberName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{memberName}}}");
        if ((((signed int)args_cnt)-1) >= {{{member_index}}})
            jerry_release_value(jerry_set_property(new_{{{dictionaryName}}}, {{{memberName}}}_prop_name, args_p[{{{member_index}}}]));
        else
        {
            Interpreter_Type default_value = {{#C_and_Jerryscript_Types}}interpreter_create_{{{Jerryscript_Type}}}({{#is_string}}(jerry_char_t *){{/is_string}}{{{default_value}}}{{/C_and_Jerryscript_Types}});
            jerry_release_value(jerry_set_property(new_{{{dictionaryName}}}, {{{memberName}}}_prop_name, default_value));
        }
        jerry_release_value({{{memberName}}}_prop_name);
    }
    {{/members}}

    return new_{{{dictionaryName}}};
} /* create_{{{dictionaryName}}}_dictionary_handler */
{{/body}}

void initialize_{{{dictionaryName}}}_(void){{#header}};{{/header}}
{{#body}}
{
    /* first, check to see if the prototype object exists for this
       dictionary; if so, just return */
    Interpreter_Type prototype = get_prototype((char *)"{{{dictionaryName}}}");
    if (!jerry_value_has_error_flag(prototype) &&
        !jerry_value_is_undefined(prototype))
    {
        jerry_release_value(prototype);
	return;
    }

    /* create the prototype object */
    Interpreter_Type global_object = jerry_get_global_object();

    /* add all of the dictionary fields, and set them to undefined */
    Interpreter_Type {{{dictionaryName}}}_prototype_object = jerry_create_object();
    {{#members}}
    add_field_to_object({{{dictionaryName}}}_prototype_object,
                           "{{{memberName}}}", NULL);
    {{/members}}

    /* store the prototype in the global prototypes holder */
    register_prototype((char *)"{{{dictionaryName}}}", {{{dictionaryName}}}_prototype_object);
    jerry_release_value({{{dictionaryName}}}_prototype_object);

    /* this sets up the ability to "new" the object */
    add_field_to_object(global_object, "{{{dictionaryName}}}", &create_{{{dictionaryName}}}_dictionary_handler);

    jerry_release_value(global_object);

    /* finally, make sure that all of the types upon which this type
       depends have been loaded; note that if there's a cycle,
       initializing all of the included data structures after we
       create this one should(?) keep us from running infinitely */
{{#externalTypes}}
    initialize_{{{type}}}_();
{{/externalTypes}}
{{#non_intrinsic_types}}
    initialize_{{{type_name}}}_();
{{/non_intrinsic_types}}

} /* initialize_{{{dictionaryName}}}_ */

/* we need to register the initialize_{{{dictionaryName}}}_ function so
   that it gets run automatically... */
__attribute__((constructor))
static void register_initialize_{{{dictionaryName}}}(void)
{
    /* ...supplied by webidl_utilities */
    {{{dictionaryName}}}_uid = get_type_uid();

    /* ...supplied by webidl_utilities... */
    register_initialization_function(initialize_{{{dictionaryName}}}_);
} /* register_initialize_{{{dictionaryName}}} */

{{/body}}
{{#debug_printing}}
{{! TODO: THIS DOES NOT HANDLE ARRAYS! }}
void debug_print_{{{dictionaryName}}} (char *variable_name,
     				      {{{dictionaryName}}} value,
				      unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
   /* we can get into infinite recursion, with one structure printing
      a second, which prints the first, and so on -- a simple
      mechnism would be to return whenever the indentation (which
      tracks recursion depth) gets too big */
   if (indentation > DEBUG_RECURSION_DEPTH_TOO_BIG)
   {
       printf("%*s%s -- RECURSION HALTED\n", indentation, "", variable_name);
       return;
   }


   {{#is_array_object}}
   printf("%*s%s:\n%*s[\n", indentation, "", variable_name, indentation, "");
   {{#members}}
   {{#C_and_Jerryscript_Types}}
   {{#is_array}}
   for(int i = 0; i < value.length; i++)
          debug_print_{{{C_Type}}}(debug_itoa(i), value.items[i], indentation+DEBUG_INDENTATION_WIDTH);
   {{/is_array}}
   {{/C_and_Jerryscript_Types}}
   {{/members}}
   printf("%*s]\n", indentation, "");
   {{/is_array_object}}
   {{^is_array_object}}
   printf("%*s%s:\n", indentation, "", variable_name);
   {{#members}}
   {{#C_and_Jerryscript_Types}}
   debug_print_{{{C_Type}}}("{{{memberName}}}", value.{{{memberName}}}, indentation+DEBUG_INDENTATION_WIDTH);
   {{/C_and_Jerryscript_Types}}

   {{/members}}
   {{/is_array_object}}
} /* debug_print_{{{dictionaryName}}} */
{{/body}}
{{/debug_printing}}

{{#header}}

#endif /* {{{dictionaryName}}}_H_ */
{{/header}}
{{/dictionaries}}
{{/OBEYFORMATTING}}
