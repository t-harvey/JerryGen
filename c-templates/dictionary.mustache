{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{! This one .mustache file is used to create both the .h and the .c
    *_Types files -- look for the "body" and "header" markers }}
{{#print_generation_message}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{/print_generation_message}}
{{#dictionaries}}
{{#header}}
#ifndef {{{dictionaryName}}}_H_
#define {{{dictionaryName}}}_H_
{{/header}}

#include "jerryscript.h"
#include "{{{utilities_filename}}}.h"

{{#header}}
{{#externalTypes}}
#include "{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}
{{/header}}
{{#body}}
#include "{{{dictionaryName}}}.h"
{{/body}}

{{! we need to define the type before any of the external includes,
    which might need to use this type }}
{{#header}}
typedef struct {
	{{#members}}
    {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}{{#is_array_object}}{{#is_array}} *{{/is_array}}{{/is_array_object}} {{{memberName}}};
    {{/C_and_Jerryscript_Types}}
	{{/members}}
} {{{dictionaryName}}};

/********************* IGNORE FUNCTIONS BELOW THIS LINE *********************/

{{/header}}
/* this variable is used in composite types to denote a field of type
   {{{interfaceName}}} -- this should be considered a read-only value */
{{#header}}extern {{/header}}int {{{dictionaryName}}}_uid;

/* all WebIDL constructs have a constructor function, so that C code
   can build any of these constructs */
{{{dictionaryName}}} {{{dictionaryName}}}_constructor(void){{#header}};{{/header}}
{{#body}}
{
    {{{dictionaryName}}} new_{{{dictionaryName}}};
    {{#is_array_object}}
    new_{{{dictionaryName}}}.length = 0;
    new_{{{dictionaryName}}}.items = NULL;
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    {{! the "get_default_value" function takes the string and either
    	returns the default value for the C_Type if its an intrinsic
        type or "<C_Type>_constructor()" (for WebIDL constructs) }}

    {{#C_and_Jerryscript_Types}}
    new_{{{dictionaryName}}}.{{{memberName}}} = {{{default_value}}};
    {{/C_and_Jerryscript_Types}}
    {{/members}}
    {{/is_array_object}}

    return new_{{{dictionaryName}}};
} /* {{{dictionaryName}}}_constructor */
{{/body}}

{{^original_arg_handling}}
{{#body}}
static jerry_value_t get_dictionary_properties()
{
    return 0;
} /* get_dictionary_properties */
{{/body}}
jerryx_arg_t
{{{Interpreter.interpreter}}}_arg_{{{dictionaryName}}}({{{dictionaryName}}}* destination,
			{{{Interpreter.interpreter}}}_arg_optional_flag_enum_type optional_flag){{#header}};{{/header}}
{{#body}}
{
    /* the set up of the jerryx_arg_t is cribbed from
       https://tinyurl.com/yc8qjpna */
    static const char *prop_name_p[] = { {{#members}}"{{{memberName}}}"{{^finalMember}}, {{/finalMember}}{{/members}} };
    static jerryx_arg_t prop_mapping[{{{members.length}}}];
    {{#members}}
      {{#C_and_Jerryscript_Types}}
	prop_mapping[{{{member_index}}}] = {{{Interpreter.interpreter}}}_arg_{{{C_Type}}} (&(destination->{{{memberName}}}), INTERPRETER_ARG_REQUIRED);
      {{/C_and_Jerryscript_Types}}
    {{/members}}

    const jerryx_arg_object_props_t prop_info =
    {
        .name_p =    (const jerry_char_t **) prop_name_p,
	.name_cnt =  {{{members.length}}},
	.c_arg_p =   prop_mapping,
	.c_arg_cnt = {{{members.length}}}
    };
    return jerryx_arg_object_properties(&prop_info,
					(jerryx_arg_optional_t)optional_flag);
} /* {{{Interpreter.interpreter}}}_arg_{{{dictionaryName}}} */
{{/body}}
{{/original_arg_handling}}
{{! really, these functions should be named "get_..._struct" rather
    than "get_..._value" -- but b/c Jerryscript already has get_*_value
    for all of the builtin types, it's easier to follow that naming
    scheme for dictionaries and interfaces...}}
{{{dictionaryName}}} {{{Interpreter.interpreter}}}_get_{{{dictionaryName}}}_value({{{Interpreter.Type}}} value){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} object_value = jerry_value_to_object(value);
    {{{dictionaryName}}} return_struct;

    {{#is_array_object}}
    {
	unsigned int array_length = jerry_get_array_length(value);
        {{! we're not really looping through the members, here, b/c we know
	    that this is an array type, so the first member will be the
	    length value, and the second member will be the actual array,
	    and the way to differentiate the two fields will be by looking
	    for the is_array flag in the C_and_Jerryscript_Types value }}
        {{#members}}
            {{#C_and_Jerryscript_Types}}
                {{^is_array}}
	return_struct.length = array_length; /* we know the field names of this
                                               dictionary (b/c it's an array) */
                {{/is_array}}
                {{#is_array}}
        return_struct.items = ({{{C_Type}}} *)malloc(sizeof({{{C_Type}}})*array_length);
        for(int i = 0; i < array_length; i++)
            return_struct.items[i] = ({{{C_Type}}}){{{Interpreter.interpreter}}}_get_{{{C_Type}}}_value(jerry_get_property_by_index(value, i));
                {{/is_array}}
            {{/C_and_Jerryscript_Types}}

         {{/members}}
    }
    {{/is_array_object}}
    {{^is_array_object}}
        {{#members}}
    {{{Interpreter.Type}}} {{{memberName}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{memberName}}}");
    {{{Interpreter.Type}}} {{{memberName}}}_value = jerry_get_property(object_value, {{{memberName}}}_prop_name);
            {{#C_and_Jerryscript_Types}}
    return_struct.{{{memberName}}} = ({{{C_Type}}}){{{Interpreter.interpreter}}}_get_{{{C_Type}}}_value({{{memberName}}}_value);
            {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{memberName}}}_prop_name);
    jerry_release_value({{{memberName}}}_value);

         {{/members}}
    {{/is_array_object}}

    jerry_release_value(object_value);

    return return_struct;
} /* {{{Interpreter.interpreter}}}_get_{{{dictionaryName}}}_value */

{{/body}}
{{#is_array_object}}
{{{dictionaryName}}} {{{Interpreter.interpreter}}}_get_{{{dictionaryName}}}_value_from_args(
		                              int starting_index,
	             			      const {{{Interpreter.Type}}} *args_p,
	                                      const jerry_length_t args_cnt){{#header}};{{/header}}
{{#body}}
{
    {{{dictionaryName}}} return_array = {0, 0};

    {{! we're not really looping through the members, here, b/c we know
	that this is an array type, so the first member will be the
	length value, and the second member will be the actual array,
	and the way to differentiate the two fields will be by looking
	for the is_array flag in the C_and_Jerryscript_Types value }}
{{#members}}
 {{#C_and_Jerryscript_Types}}
  {{^is_array}}              {{! array length}}
    unsigned int array_length = args_cnt-starting_index;
    return_array.length = array_length;

  {{/is_array}}
  {{#is_array}}              {{! array values }}
    if (array_length > 0)
    {
        return_array.items = ({{{C_Type}}} *)malloc(sizeof({{{C_Type}}})*array_length);
	/* TODO: check that malloc succeeded */
    }

    /* i is the index in the new array, loop_counter walks the args array */
    for(int i = 0, loop_counter = starting_index;
	loop_counter < args_cnt;
	i++, loop_counter++)
	return_array.items[i] = ({{{C_Type}}}){{{Interpreter.interpreter}}}_get_{{{C_Type}}}_value(args_p[loop_counter]);

  {{/is_array}}
 {{/C_and_Jerryscript_Types}}
{{/members}}
    return return_array;
} /* {{{Interpreter.interpreter}}}_get_{{{dictionaryName}}}_value_from_args */

{{/body}}
{{/is_array_object}}
/* like all the {{{Interpreter.interpreter}}}_create_* functions, this one takes a C
   variable and creates its Jerryscript/Javascript equivalent */
{{{Interpreter.Type}}} {{{Interpreter.interpreter}}}_create_{{{dictionaryName}}}({{{dictionaryName}}} x){{#header}};{{/header}}
{{#body}}
{
    {{{Interpreter.Type}}} new_jerry_value = jerry_create_object();

    {{#is_array_object}}
    {{#members}}
    {{#C_and_Jerryscript_Types}}
    {{#is_array}}
    for (int i = 0; i < x.length; i++)
    {
        {{{Interpreter.Type}}} next = {{{Interpreter.interpreter}}}_{{#is_object}}_{{/is_object}}create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}(x.items[i]));
    	jerry_release_value(jerry_set_property_by_index(new_jerry_value, i, next));
    	jerry_release_value(next);
    }
    {{/is_array}}
    {{/C_and_Jerryscript_Types}}
    {{/members}}
    {{/is_array_object}}
    {{^is_array_object}}
    {{#members}}
    {{{Interpreter.Type}}} {{{memberName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{memberName}}}");
    {{#C_and_Jerryscript_Types}}
    {{{Interpreter.Type}}} {{{memberName}}}_value = {{{Interpreter.interpreter}}}_{{#is_object}}_{{/is_object}}create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *){{/is_string}}x.{{{memberName}}});
    {{/C_and_Jerryscript_Types}}
    jerry_release_value(jerry_set_property(new_jerry_value, {{{memberName}}}_prop_name, {{{memberName}}}_value));
    jerry_release_value({{{memberName}}}_value);
    jerry_release_value({{{memberName}}}_prop_name);

    {{/members}}
    {{/is_array_object}}

    return new_jerry_value;
    
} /* {{{Interpreter.interpreter}}}_create_{{{dictionaryName}}} */

{{/body}}

bool {{{Interpreter.interpreter}}}_value_is_{{{dictionaryName}}}({{{Interpreter.Type}}} thing_value){{#header}};{{/header}}
{{#body}}
{
    {{#is_array_object}}
    if (!jerry_value_is_array(thing_value))
        return false;
    else
    {
        if (jerry_get_array_length(thing_value) == 0)
	    return true;
	else
	{
	{{! TODO: maybe check every element? }}
	{{#members}}
	{{#C_and_Jerryscript_Types}}
	{{#is_array}}
	    jerry_value_t first_element =
	                          jerry_get_property_by_index(thing_value, 0);
	    bool is_target_value = {{{Interpreter.interpreter}}}_value_is_{{{C_and_Jerryscript_Types.C_Type}}}(first_element);
	    jerry_release_value(first_element);

	    return is_target_value;
	{{/is_array}}
	{{/C_and_Jerryscript_Types}}
	{{/members}}
	}
    }        
    {{/is_array_object}}
    {{^is_array_object}}
    /* it's perfectly legal for a dictionary to be built without using
       "new", in which case, checking its type won't give us the
       actual dictionary type we're looking for -- it'll just give us
       "object"; instead, we'll walk through an object's fields and,
       	if they're all there and of the right type, then we'll return true */
{{#members}}
        if (!{{{Interpreter.interpreter}}}__has_own_property(thing_value,
                                          "{{{memberName}}}"))
            return false;
        else
        {
{{#C_and_Jerryscript_Types}}
            {{{Interpreter.Type}}} field = {{{Interpreter.interpreter}}}__get_property(thing_value,
                                                            "{{{memberName}}}");
	    bool value_is_right_type = {{{Interpreter.interpreter}}}_{{#is_object}}_{{/is_object}}value_is_{{{C_Type}}}(field);
            jerry_release_value(field);

            if (!value_is_right_type)
                return false;
{{/C_and_Jerryscript_Types}}
        }
{{/members}}

    /* fall-through indicates that we have an object of this type */
    return true;
    {{/is_array_object}}
} /* {{{Interpreter.interpreter}}}_value_is_{{{dictionaryName}}} */
{{/body}}

{{#body}}
static {{{Interpreter.Type}}}
create_{{{dictionaryName}}}_dictionary_handler(const {{{Interpreter.Type}}} func_value,
                   const {{{Interpreter.Type}}} this_val,
                   const {{{Interpreter.Type}}} *args_p,
                   const jerry_length_t args_cnt)
{
    {{{Interpreter.Type}}} new_{{{dictionaryName}}} = jerry_create_object();
    {{{Interpreter.Type}}} prototype = get_prototype((char *) "{{{dictionaryName}}}");
    jerry_release_value(jerry_set_prototype(new_{{{dictionaryName}}}, prototype));
    jerry_release_value(prototype);

    {{#members}}
    {
        {{{Interpreter.Type}}} {{{memberName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{memberName}}}");
        if ((((signed int)args_cnt)-1) >= {{{member_index}}})
            jerry_release_value(jerry_set_property(new_{{{dictionaryName}}}, {{{memberName}}}_prop_name, args_p[{{{member_index}}}]));
        else
        {
            {{{Interpreter.Type}}} default_value = {{#C_and_Jerryscript_Types}}{{{Interpreter.interpreter}}}_{{#is_object}}_{{/is_object}}create_{{{Jerryscript_Type}}}({{#is_string}}(jerry_char_t *){{/is_string}}{{{default_value}}}{{/C_and_Jerryscript_Types}});
            jerry_release_value(jerry_set_property(new_{{{dictionaryName}}}, {{{memberName}}}_prop_name, default_value));
        }
        jerry_release_value({{{memberName}}}_prop_name);
    }
    {{/members}}

    return new_{{{dictionaryName}}};
} /* create_{{{dictionaryName}}}_dictionary_handler */
{{/body}}

void initialize_{{{dictionaryName}}}_(void){{#header}};{{/header}}
{{#body}}
{
    /* first, check to see if the prototype object exists for this
       dictionary; if so, just return */
    {{{Interpreter.Type}}} prototype = get_prototype((char *)"{{{dictionaryName}}}");
    if (!jerry_value_is_error(prototype) &&
        !jerry_value_is_undefined(prototype))
    {
        jerry_release_value(prototype);
	return;
    }

    /* create the prototype object */
    {{{Interpreter.Type}}} global_object = jerry_get_global_object();

    /* add all of the dictionary fields, and set them to undefined */
    {{{Interpreter.Type}}} {{{dictionaryName}}}_prototype_object = jerry_create_object();
    {{#members}}
    add_field_to_object({{{dictionaryName}}}_prototype_object,
                           "{{{memberName}}}", NULL);
    {{/members}}

    /* store the prototype in the global prototypes holder */
    register_prototype((char *)"{{{dictionaryName}}}", {{{dictionaryName}}}_prototype_object);
    jerry_release_value({{{dictionaryName}}}_prototype_object);

    /* this sets up the ability to "new" the object */
    add_field_to_object(global_object, "{{{dictionaryName}}}", &create_{{{dictionaryName}}}_dictionary_handler);

    jerry_release_value(global_object);

    /* finally, make sure that all of the types upon which this type
       depends have been loaded; note that if there's a cycle,
       initializing all of the included data structures after we
       create this one should(?) keep us from running infinitely */
{{#externalTypes}}
    initialize_{{{type}}}_();
{{/externalTypes}}
{{#non_intrinsic_types}}
  {{! typedef'd types don't need an initialization if their ultimate
      type is a primitive type (since those don't have initializors) }}
  {{#needs_initialization}}
    initialize_{{{type_name}}}_();
  {{/needs_initialization}}
{{/non_intrinsic_types}}

} /* initialize_{{{dictionaryName}}}_ */

/* we need to register the initialize_{{{dictionaryName}}}_ function so
   that it gets run automatically... */
__attribute__((constructor))
static void register_initialize_{{{dictionaryName}}}(void)
{
    /* ...supplied by webidl_utilities */
    {{{dictionaryName}}}_uid = get_type_uid();

    /* ...supplied by webidl_utilities... */
    register_initialization_function(initialize_{{{dictionaryName}}}_);
} /* register_initialize_{{{dictionaryName}}} */

{{/body}}
{{#debug_printing}}
{{! TODO: THIS DOES NOT HANDLE ARRAYS! }}
void debug_print_{{{dictionaryName}}} (char *variable_name,
     				      {{{dictionaryName}}} value,
				      unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
   /* we can get into infinite recursion, with one structure printing
      a second, which prints the first, and so on -- a simple
      mechnism would be to return whenever the indentation (which
      tracks recursion depth) gets too big */
   if (indentation > DEBUG_RECURSION_DEPTH_TOO_BIG)
   {
       printf("%*s%s -- RECURSION HALTED\n", indentation, "", variable_name);
       return;
   }


   {{#is_array_object}}
   printf("%*s%s:\n%*s[\n", indentation, "", variable_name, indentation, "");
   {{#members}}
   {{#C_and_Jerryscript_Types}}
   {{#is_array}}
   for(int i = 0; i < value.length; i++)
          debug_print_{{{C_Type}}}(debug_itoa(i), value.items[i], indentation+DEBUG_INDENTATION_WIDTH);
   {{/is_array}}
   {{/C_and_Jerryscript_Types}}
   {{/members}}
   printf("%*s]\n", indentation, "");
   {{/is_array_object}}
   {{^is_array_object}}
   printf("%*s%s:\n", indentation, "", variable_name);
   {{#members}}
   {{#C_and_Jerryscript_Types}}
   debug_print_{{{C_Type}}}("{{{memberName}}}", value.{{{memberName}}}, indentation+DEBUG_INDENTATION_WIDTH);
   {{/C_and_Jerryscript_Types}}

   {{/members}}
   {{/is_array_object}}
} /* debug_print_{{{dictionaryName}}} */
{{/body}}
{{/debug_printing}}

{{#header}}

#endif /* {{{dictionaryName}}}_H_ */
{{/header}}
{{/dictionaries}}
{{/OBEYFORMATTING}}
