{{! Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
}}

{{! Mustache doesn't understand how to transfer blank lines from this
    script file to the output file unless those blank lines are within
    a #<name> construct, so we wrap this entire script with a name
    that shouldn't(?)(!) be in the input file }}
{{^OBEYFORMATTING}}
{{#interfaces}}
{{#print_generation_message}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */
{{/print_generation_message}}

{{#header}}
#ifndef {{{interfaceName}}}_H_
#define {{{interfaceName}}}_H_

{{! We have to make sure that the type is defined before any
    composites that use it are #include'd... }}
/* defined in {{{interfaceName}}}_stubs.h */
typedef Interpreter_Type {{{interfaceName}}};

{{#externalTypes}}
#include "{{{type}}}.h"
{{/externalTypes}}
{{#non_intrinsic_types}}
#include "{{{type_name}}}.h"
{{/non_intrinsic_types}}
{{#prototype_chain}}
#include "{{{parentName}}}.h"
{{/prototype_chain}}


{{/header}}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jerryscript.h"
#include "{{{utilities_filename}}}.h"
{{#body}}
#include "{{{interfaceName}}}.h"
{{/body}}

/* this variable is used in composite types to denote a field of type
   {{{interfaceName}}} -- this should be considered a read-only value */
{{#header}}extern {{/header}}int {{{interfaceName}}}_uid;

{{^repress_stubs}}
{{#header}}
struct Native_Object_{{{interfaceName}}};
{{! TODO: why do we need to include the stubs.h in this .h?!? }}
#include "{{{interfaceName}}}_stubs.h"

/********************* IGNORE FUNCTIONS BELOW THIS LINE *********************/

{{/header}}
/* all WebIDL constructs have a constructor function, so that C code
   can build any of these constructs */
{{{interfaceName}}} {{{interfaceName}}}_constructor(void){{#header}};{{/header}}
{{#body}}
{
    {{{interfaceName}}} new_{{{interfaceName}}} = create_empty_{{{interfaceName}}}();

    {{#attributes}}
    {{! the "get_default_value" function takes the string and either
    	returns the default value for the C_Type if its an intrinsic
        type or "<C_Type>_constructor()" (for WebIDL constructs) }}
    {{#C_and_Jerryscript_Types}}
    INTERFACE_INSERT(new_{{{interfaceName}}}, {{{interfaceName}}}, {{{attributeName}}}, {{{default_value}}});
    {{/C_and_Jerryscript_Types}}
    {{/attributes}}

    /* set up the native object */
    Native_Object_set((struct Native_Object_{{{interfaceName}}} *)Native_Object_{{{interfaceName}}}_create(), new_{{{interfaceName}}}, &{{{interfaceName}}}_checksum);

    return new_{{{interfaceName}}};
} /* {{{interfaceName}}}_constructor */

{{/body}}
{{/repress_stubs}}
{{#hasAttributes}}

{{#attributes.length}}
/* attribute GETTERS */
{{/attributes.length}}
{{#attributes}}
{{#C_and_Jerryscript_Types}}
{{#header}}extern {{/header}}{{{C_Type}}} extract_{{{interfaceName}}}_{{{attributeName}}} (Interpreter_Type self){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type property_pointer = jerry_create_string((const jerry_char_t *) "{{{attributeName}}}");
    Interpreter_Type attribute_pointer = jerry_get_property(self, property_pointer);
    {{{C_Type}}} return_value = ({{{C_Type}}})interpreter_get_{{{C_Type}}}_value(attribute_pointer);
    jerry_release_value(property_pointer);
    jerry_release_value(attribute_pointer);
    return return_value;
} /* extract_{{interfaceName}}_{{attributeName}} */

{{/body}}
{{#header}}extern {{/header}}void insert_{{{interfaceName}}}_{{{attributeName}}} (Interpreter_Type self, {{{C_Type}}} new_value){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type new_value_pointer =
              interpreter_create_{{{C_Type}}}({{#is_string}}(const jerry_char_t *) {{/is_string}}new_value);
    interpreter_set_property(self, "{{{attributeName}}}", new_value_pointer);
    jerry_release_value(new_value_pointer);

} /* insert_{{interfaceName}}_{{attributeName}} */

{{/body}}
{{/C_and_Jerryscript_Types}}
{{/attributes}} {{! ATTRIBUTE GETTERS/SETTERS}}

{{/hasAttributes}}
{{#repress_stubs}}
/* each Javascript object can have a single C object associated with
   it, which we call a Native_Object ("native" to the C code); these
   Native_Objects are attached to their objects by Jerryscript, and
   Jerryscript also keeps track of when the associated object is
   destroyed -- when a Javascript object is destroyed, Jerryscript
   will call a user function to deallocate the associated Native_Object;
   thus, when we assign a Native_Object to a Javascript object using
   Native_Object_set, we also give it a deallocator for that
   Native_Object (note that the function can be null if there isn't
   any memory to free) */
void Native_Object_{{{interfaceName}}}_deallocator(Native_Object_{{{interfaceName}}} *native_object){{#header}};{{/header}}
{{#body}}
{
	/* USER CODE GOES HERE */
} /* Native_Object_{{{interfaceName}}}_deallocator */

{{/body}}
Native_Object_{{{interfaceName}}} *Native_Object_{{{interfaceName}}}_create(void){{#header}};{{/header}}
{{#body}}
{
    Native_Object_{{{interfaceName}}} *new_object = (Native_Object_{{{interfaceName}}} *)malloc(sizeof(Native_Object_{{{interfaceName}}}));

	/* USER CODE GOES HERE */ 
    return new_object;
} /* Native_Object_{{{interfaceName}}}_create */
{{/body}}
{{/repress_stubs}}

{{! the checksum is used by Jerryscript to ensure that the
    Native_Object is still valid; when we make the stubs, we need to
    set up the checksum here, but also give it to the stubs file }}
{{#body}}
{{#repress_stubs}}static {{/repress_stubs}}{{^repress_stubs}}extern {{/repress_stubs}}
jerry_object_native_info_t {{{interfaceName}}}_checksum{{^repress_stubs}};{{/repress_stubs}}{{#repress_stubs}} = {Native_Object_{{{interfaceName}}}_deallocator};{{/repress_stubs}}

{{/body}}
{{#body}}
/* put all of the native-code functions (indentifable by the
 *  suffix "_handler") here: */

{{/body}}
    {{#operations}}
        {{^inherited_operation}}
Interpreter_Type
{{{interfaceName}}}_{{{operationName}}}_handler(const Interpreter_Type func_value, /**< function object */
		   const Interpreter_Type this_val, /**< this arg */
                   const Interpreter_Type *args_p, /**< function arguments */
                   const jerry_length_t args_cnt){{#header}};{{/header}} /**< number of function arguments */
{{#body}}
{
{{!
    ********************************************************************
    TODO: THIS CODE DOESN'T WORK IF THEY NEED interpreter_get_value_..._ARRAY !!!
    (b/c we don't create the get_..._Array function anywhere...)
    ********************************************************************  }}
    /* demarshal the arguments{{#repress_stubs}} and set up the Native_Object{{/repress_stubs}} */
{{! TODO: the "this_val" passed in to a function parameter: should it be
    this_val, or should we gen up a value_t for the global object? }}
    {{#arguments}}
	 {{#variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}} {{{name}}} = interpreter_get_{{{C_Type}}}_value_from_args({{{paramIndex}}}, args_p, args_cnt);
   	     {{/C_and_Jerryscript_Types}}
	 {{/variadic}}
	 {{^variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}} {{{name}}};
    if ({{{paramIndex}}} < args_cnt)
        {{{name}}} = interpreter_get_{{{C_Type}}}_value(args_p[{{{paramIndex}}}]);
    else
                 {{^optional}}
    {
	fprintf(stderr, "Too few parameters to function >{{{name}}}<\n");
	/* return; TODO: we should jump to the return code (?) */
    }
		 {{/optional}}
                 {{#optional}}
        {{{name}}} = {{{default_value}}};
		 {{/optional}}
             {{/C_and_Jerryscript_Types}}
    	 {{/variadic}}
    {{/arguments}}
{{#repress_stubs}}
    Native_Object_{{{interfaceName}}} *native_object;
    GET_NATIVE_OBJECT_OR_RETURN_ON_ERROR(this_val, native_object, &{{{interfaceName}}}_checksum);

    /* USER CODE GOES HERE */

{{/repress_stubs}}
{{^repress_stubs}}

{{#C_and_Jerryscript_Types}}
extern {{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{{C_Type}}}{{/return_is_this}} {{{interfaceName}}}_{{{operationName}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{/C_and_Jerryscript_Types}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}Interpreter_Type);
{{/C_and_Jerryscript_Types}}
{{/repress_stubs}}
{{! for the "return_value", the logic is as follows: 1) don't put out
the declaration if it's a void return type or this function returns
the this pointer; 2) if we're repressing stubs, then put it out as a
simple declaration; 3) if we're not repressing stubs, then put out the
declaration with an assignment from the stub }}
{{#repress_stubs}}{{^voidReturnType}}
/* THIS VARIABLE SHOULD HOLD THE VALUE TO BE RETURNED */{{/voidReturnType}}{{/repress_stubs}}
{{#C_and_Jerryscript_Types}}
    {{^voidReturnType}}{{^return_is_this}}{{{C_Type}}} return_value{{#repress_stubs}};{{/repress_stubs}}{{^repress_stubs}} ={{/repress_stubs}}{{/return_is_this}}{{/voidReturnType}}{{^repress_stubs}} {{{interfaceName}}}_{{{operationName}}}_body({{#arguments}}{{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#arguments.length}}, {{/arguments.length}}this_val);{{/repress_stubs}}
{{/C_and_Jerryscript_Types}}

    {{! if the return value is a string (or array of strings), we want
        to enter it into the Jerryscript environment _before_ we
        deallocate our local strings, as it's possible that the return
        value is just a copy of one of args }}
    {{#C_and_Jerryscript_Types}}
        {{#is_string}}
    {{! DOES THE FOLLOWING COVER ALL OF THE PERMUTATIONS? }}
    /* put the string into Jerryscript before we cleanup any string arguments */
    Interpreter_Type string_value = jerry_create_string((const jerry_char_t *)return_value);
        {{/is_string}}
    {{/C_and_Jerryscript_Types}}
    {{! FREE MALLOC'D STRINGS}}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	        {{#is_string}}
		{{! TODO: free array of strings! }}
		{{^is_array}}
    /*if ({{{name}}} != NULL) free({{{name}}});*/
    if (strlen({{{name}}}) != 0) free({{{name}}});
		{{/is_array}}
       		{{/is_string}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}
{{! ^repress_stubs}}
    {{#C_and_Jerryscript_Types}}
        {{#return_is_this}}
{{! return values get free'd by the interpreter, so if you don't
    return a copy of the "this" pointer, the _2nd_ (nth?) time you return
    the this pointer, the interpreter will raise an exception... }}
    /* return a reference back to this interface */
    return jerry_acquire_value(this_val);
        {{/return_is_this}}
        {{^return_is_this}}
            {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
            {{/voidReturnType}}
            {{^voidReturnType}}
                {{^is_string}}
    return interpreter_create_{{{Jerryscript_Type}}}(return_value);
                {{/is_string}}
                {{#is_string}}
     return string_value;
                {{/is_string}}
            {{/voidReturnType}}
        {{/return_is_this}}
    {{/C_and_Jerryscript_Types}}
{{! /repress_stubs}}
} /* {{{interfaceName}}}_{{{operationName}}}_handler */

{{/body}}
	{{/inherited_operation}}
    {{/operations}}

{{#body}}
static Interpreter_Type
create_{{{interfaceName}}}_interface_handler(const Interpreter_Type func_value,
		   const Interpreter_Type this_val,
                   const Interpreter_Type *args_p,
                   const jerry_length_t args_cnt)
{
{{! If the object has been specified as no-interface, then the user's
    not allowed to create a new one of these; for now, return the
    (single) global object instead of an error }}
{{#NoInterfaceObject}}
    Interpreter_Type object_name = jerry_create_string((const jerry_char_t *) "{{{interfaceName}}}");
    Interpreter_Type global_object = jerry_get_global_object();
    /* THIS IS A nointerfaceobject, SO WE'RE RETURNING THE (SINGLE) GLOBAL
       INSTANCE */
    Interpreter_Type object = jerry_get_property(global_object, object_name);
    jerry_release_value(object_name);
    jerry_release_value(global_object);
    return object;
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    Interpreter_Type new_{{{interfaceName}}} = jerry_create_object();

    {{#attributes}}
    if ((((signed int)args_cnt)-1) >= {{{attribute_index}}})
    {
        Interpreter_Type {{{attributeName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{attributeName}}}");
        jerry_release_value(jerry_set_property(new_{{{interfaceName}}}, {{{attributeName}}}_prop_name, args_p[{{{attribute_index}}}]));
        jerry_release_value({{{attributeName}}}_prop_name);
    }
    else
    {
    {{#C_and_Jerryscript_Types}}
        Interpreter_Type {{{attributeName}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{attributeName}}}");
	Interpreter_Type {{{attributeName}}}_default_value = interpreter_create_{{{Jerryscript_Type}}}({{#is_string}}(const jerry_char_t *) {{/is_string}}{{{default_value}}});
        jerry_release_value(jerry_set_property(new_{{{interfaceName}}}, {{{attributeName}}}_prop_name, {{{attributeName}}}_default_value));
        jerry_release_value({{{attributeName}}}_default_value);
        jerry_release_value({{{attributeName}}}_prop_name);
    {{/C_and_Jerryscript_Types}}
    }

    {{/attributes}}
    {{! Note that we pushed the parents into the array as if it were a
     	stack, so that children override parent methods (b/c they come
	later when we walk through the array, and jerry_set_prototype
	overwrites the old with the new) }}
    {{! TODO: check to see if an actual prototype is returned from the
        following call: }}
    {{#prototype_chain}}
    Interpreter_Type prototype_{{{parentName}}} = get_prototype((char *)"{{{parentName}}}");
    jerry_release_value(jerry_set_prototype(new_{{{interfaceName}}},
					    prototype_{{{parentName}}}));
    jerry_release_value(prototype_{{{parentName}}});
    {{/prototype_chain}}

    {{! ...and, of course, we overlay the current object's prototype
        last so that its methods override all of its ancestors }}
    Interpreter_Type prototype = get_prototype((char *)"{{{interfaceName}}}");
    jerry_release_value(jerry_set_prototype(new_{{{interfaceName}}},
					    prototype));
    jerry_release_value(prototype);


    /* set up the Native_Object for the new object */
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_{{{interfaceName}}}_create();
    Native_Object_set(native_object, new_{{{interfaceName}}}, &{{{interfaceName}}}_checksum);

    return new_{{{interfaceName}}};
{{/NoInterfaceObject}}
} /* create_{{{interfaceName}}}_interface_handler */

{{/body}}
/* we need this when we want to create a structure with the
   interface's operations, but we don't (yet?) have any values for the
   attributes */
Interpreter_Type create_empty_{{{interfaceName}}}(){{#header}};{{/header}}
{{#body}}
{
    Interpreter_Type dummy_jerry_value;
    Interpreter_Type empty_{{{interfaceName}}} =
                    create_{{{interfaceName}}}_interface_handler(dummy_jerry_value,
							dummy_jerry_value,
							&dummy_jerry_value,
							0);
    return empty_{{{interfaceName}}};
} /* create_empty_{{{interfaceName}}} */
{{/body}}

void initialize_{{{interfaceName}}}_(void){{#header}};{{/header}}
{{#body}}
{
    /* first, make sure that this prototype doesn't already exist */
    Interpreter_Type existing_prototype = get_prototype((char *)"{{{interfaceName}}}");
    if (!jerry_value_is_error(existing_prototype) &&
        !jerry_value_is_undefined(existing_prototype))
    {
        jerry_release_value(existing_prototype);
	return;
    }

    /* create the prototype object */
    {{! for attributes: attributes cannot get a default value, which
       means that they don't need to be created now; Javascript
       automagically creates them when they're first defined, so we
       don't need to do anything -- we probably don't need to do
       anything in the object version of the interface, either, but it
       looks nice... }}
    {{! IS THE ABOVE STILL TRUE?  WHAT IF IT'S A NOINTERFACEOBJECT? }}
    Interpreter_Type global_object = jerry_get_global_object();

    /* create a new object to hold all of the interface prototypes */
    Interpreter_Type {{{interfaceName}}}_prototype_object = jerry_create_object();
    {{#operations}}
    add_field_to_object({{{interfaceName}}}_prototype_object,
                        "{{{operationName}}}", &{{#inherited_operation}}{{{defining_interface}}}{{/inherited_operation}}{{^inherited_operation}}{{{interfaceName}}}{{/inherited_operation}}_{{{operationName}}}_handler);
    {{/operations}}

{{! if it's specified as a NoInterfaceObject, then the object goes
    into the global namespace; otherwise, the object is used as a
    prototype, so record it in the global prototypes holder }}
{{#NoInterfaceObject}}
    /* set up the Native_Object for the new object */
    Native_Object_{{{interfaceName}}} *native_object = Native_Object_{{{interfaceName}}}_create();
    Native_Object_set(native_object, {{{interfaceName}}}_prototype_object, &{{{interfaceName}}}_checksum);

    Interpreter_Type object_name = jerry_create_string((const jerry_char_t *) "{{{interfaceName}}}");
    jerry_release_value(jerry_set_property(global_object,
					   object_name,
					   {{{interfaceName}}}_prototype_object));
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    register_prototype((char *)"{{{interfaceName}}}", {{{interfaceName}}}_prototype_object);
{{/NoInterfaceObject}}
    jerry_release_value({{{interfaceName}}}_prototype_object);

{{^NoInterfaceObject}}
{{! this sets up the ability to "new" the object, if it's not been specified
    as NoInterface or ReturnFromRequire }}
{{^is_module}}
    add_field_to_object(global_object, "{{{interfaceName}}}",
                        &create_{{{interfaceName}}}_interface_handler);

{{/is_module}}
{{/NoInterfaceObject}}
    jerry_release_value(global_object);

    /* finally, make sure that all of the types upon which this type
       depends have been loaded; note that if there's a cycle,
       initializing all of the included data structures after we
       create this one should(?) keep us from running infinitely */
{{#externalTypes}}
    initialize_{{{type}}}_();
{{/externalTypes}}
{{#non_intrinsic_types}}
  {{! typedef'd types don't need an initialization if their ultimate
      type is a primitive type (since those don't have initializors) }}
  {{#needs_initialization}}
    initialize_{{{type_name}}}_();
  {{/needs_initialization}}
{{/non_intrinsic_types}}
{{#prototype_chain}}
    initialize_{{{parentName}}}_();
{{/prototype_chain}}

} /* initialize_{{{interfaceName}}}_ */
{{/body}}

{{! if it's a type returned by a module, then the procedure is
    (mostly) the same as when we're setting up the template object:
    the difference is that for regular interfaces, we create the
    prototype object of methods and store it under the global object,
    whereas for module objects, we call a stub to create the object
    and then just graft the methods onto it and return it }}
{{#is_module}}
{{#body}}
static Interpreter_Type {{{interfaceName}}}_require_function_(void)
{
    /* make sure that all of the types upon which this type depends
       have been initialized */
{{#externalTypes}}
    initialize_{{{type}}}_();
{{/externalTypes}}
{{#non_intrinsic_types}}
  {{! typedef'd types don't need an initialization if their ultimate
      type is a primitive type (since those don't have initializors) }}
  {{#needs_initialization}}
    initialize_{{{type_name}}}_();
  {{/needs_initialization}}
{{/non_intrinsic_types}}
{{! TODO: handle repress_stubs }}

    /* let the user set up the object and then map the operations onto it */
    Interpreter_Type new_{{{interfaceName}}} =
                     interpreter_create_{{{interfaceName}}}(require_{{{interfaceName}}}_body());

    Interpreter_Type prototype = get_prototype((char *)"{{{interfaceName}}}");
    jerry_release_value(jerry_set_prototype(new_{{{interfaceName}}},
					    prototype));
    jerry_release_value(prototype);
   
    return new_{{{interfaceName}}};
} /* {{{interfaceName}}}_require_function_ */
{{/body}}
{{/is_module}}

{{#body}}
/* we need to register the initialize_{{{interfaceName}}}_ function so
   that it gets run automatically... */
__attribute__((constructor))
static void register_initialize_{{{interfaceName}}}(void)
{
    /* ...supplied by webidl_utilities */
    {{{interfaceName}}}_uid = get_type_uid();

    /* ...supplied by webidl_utilities... */
    register_initialization_function(initialize_{{{interfaceName}}}_);

{{#is_module}}
    /* ...supplied by webidl_utilities... */
    register_require_function("{{{interfaceName}}}",
                              {{{interfaceName}}}_require_function_);

{{/is_module}}
} /* register_initialize_{{{interfaceName}}} */

{{/body}}
{{! INTERFACE GETTER/SETTER: }}
{{{interfaceName}}} interpreter_get_{{{interfaceName}}}_value(Interpreter_Type value){{#header}};{{/header}}
{{#body}}
{
    /* interfaces live on the Javascript side, so "value" is already
        of the correct type */
    return value;

} /* interpreter_get_{{{interfaceName}}}_value */

{{/body}}
/* like all the interpreter_create_* functions, this one takes a C
   variable and creates its Jerryscript/Javascript equivalent */
Interpreter_Type interpreter_create_{{{interfaceName}}}({{{interfaceName}}} x){{#header}};{{/header}}
{{#body}}
{
    /* interfaces are stored over on the Javascript side, so "x" is
       already the correct type; we need to create a new version of
       the handle so that the user can "release" his */
    return jerry_acquire_value(x);

} /* interpreter_create_{{{interfaceName}}} */

{{/body}}
{{#AAAheader}}
{{#AAAtypedefs}}
#define interpreter_create_{{{name}}} interpreter_create_{{{type}}}
{{/AAAtypedefs}}
{{/AAAheader}}
bool interpreter_value_is_{{{interfaceName}}}(Interpreter_Type thing_value){{#header}};{{/header}}
{{#body}}
{
    {{#attributes}}
    if (!interpreter_has_own_property(thing_value, "{{{attributeName}}}"))
            return false;
    else
    {
{{#C_and_Jerryscript_Types}}
        Interpreter_Type field = interpreter_get_property(thing_value,
                                                         "{{{attributeName}}}");
	bool value_is_right_type = interpreter_value_is_{{{C_Type}}}(field);
        jerry_release_value(field);

        if (!value_is_right_type)
            return false;
{{/C_and_Jerryscript_Types}}
    }

    {{/attributes}}

    /* the best we can do for operations is test if: a) they exist,
       and b) they have the right number of parameters */
    jerry_value_t length_property = 
                           jerry_create_string((const jerry_char_t *)"length");

    {{#operations}}
    if (!interpreter_has_own_property(thing_value, "{{{operationName}}}"))
    {
        /* check to see if this object inherited the operation */
        if (interpreter_has_property(thing_value, "{{{operationName}}}"))
	{
	    jerry_value_t parent = jerry_get_prototype(thing_value);
	    bool parent_has_operation = interpreter_has_own_property(parent, "{{{operationName}}}");

	    /* TODO: IF YOU RELEASE THE jerry_value_t FOR THE PROTOTYPE, THE
   	       INTERPRETER THROWS AN EXCEPTION:
	    jerry_release_value(parent);
	    */
	    if (!parent_has_operation)
	        return false;
	}
	else
            return false;
    }
    else
    {
{{#C_and_Jerryscript_Types}}
        Interpreter_Type field = interpreter_get_property(thing_value,
                                                         "{{{operationName}}}");
        jerry_value_t length_value =
	                     jerry_get_property(field, length_property);
	int number_of_parameters =
	(int)jerry_get_number_value(length_value);
        jerry_release_value(field);
        jerry_release_value(length_value);

        if (number_of_parameters != {{{arguments.length}}})
            return false;
{{/C_and_Jerryscript_Types}} 
    }	

    {{/operations}}
    /* fall-through indicates success */
    return true;
} /* interpreter_value_is_{{{interfaceName}}} */

{{/body}}
{{#debug_printing}}
void debug_print_{{{interfaceName}}} (char *variable_name,
     				      {{{interfaceName}}} value,
				      unsigned int indentation){{#header}};{{/header}}
{{#body}}
{
    /* we can get into infinite recursion, with one structure printing
       a second, which prints the first, and so on -- a simple
       mechnism would be to return whenever the indentation (which
       tracks recursion depth) gets too big */
   if (indentation > DEBUG_RECURSION_DEPTH_TOO_BIG)
   {
       printf("%*s%s -- RECURSION HALTED\n", indentation, "", variable_name);
       return;
   }

   printf("%*s%s:\n", indentation, "", variable_name);
{{^attributes.length}}
   printf("%*sNO ATTRIBUTES TO PRINT\n", indentation+DEBUG_INDENTATION_WIDTH, "");
{{/attributes.length}}
{{#attributes}}
        debug_print_{{{C_and_Jerryscript_Types.C_Type}}}("{{{attributeName}}}",
	INTERFACE_EXTRACT(value, {{{interfaceName}}}, {{{attributeName}}}),
	                         indentation+DEBUG_INDENTATION_WIDTH);
{{/attributes}}

} /* debug_print_{{{interfaceName}}} */
{{/body}}
{{/debug_printing}}

{{#header}}

#endif /* {{{interfaceName}}}_H_ */
{{/header}}
{{/interfaces}}
{{/OBEYFORMATTING}}
