/* AUTOMATICALLY GENERATED ON {{timestamp}} */

#include <stdio.h>
#include <stdlib.h>

#include "jerry-api.h"

// If the user has dictionary types, we'll do all of the #includes
// there, and we'll get them for free when we include the .h file for the
// dictionaries; but if they didn't add any dictionaries, we need to
// ensure that the .c file gets the necessary #includes
{{#hasDictTypes}}
#include "{{{moduleName}}}_Types.h"
{{/hasDictTypes}}
{{^hasDictTypes}}
{{#library_includes}}
#include <{{{name}}}>
{{/library_includes}}
{{#local_includes}}
#include "{{{name}}}"
{{/local_includes}}
{{/hasDictTypes}}

/*#include "jerry-port.h"*/
/*#include "jerry-port-default.h"*/

{{! each object needs a get and create function }}
{{! start with declarations, in case of ordering problems }}
{{#dictionaries}}
static {{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value);
static jerry_value_t jerry_create_{{{name}}}({{{name}}} x);
{{/dictionaries}}

{{#interfaces}}
{{#NoInterfaceObject}}
static jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt);
{{/NoInterfaceObject}}
{{/interfaces}}

{{! really, these functions should be named "get_..._struct" rather
    than "get_..._value" -- but b/c Jerryscript already has get_*_value
    for all of the builtin types, it's easier to follow that naming
    scheme for dictionaries and interfaces...}}

{{#dictionaries}}
static {{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value)
{
    jerry_value_t object_value = jerry_value_to_object(value);
    {{{name}}} return_struct;

    {{#members}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t {{{name}}}_value = jerry_get_property(object_value, {{{name}}}_prop_name);
    {{#C_and_Jerryscript_Types}}
    return_struct.{{{name}}} = (int)jerry_get_{{{Jerryscript_Type}}}_value({{{name}}}_value);
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    jerry_release_value({{{name}}}_value);
//
    {{/members}}

    jerry_release_value(object_value);

    return return_struct;
} /* jerry_get_{{{name}}}_value */

static jerry_value_t jerry_create_{{{name}}}({{{name}}} x)
{
    jerry_value_t new_jerry_value = jerry_create_object();

    {{#members}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
    {{#C_and_Jerryscript_Types}}
    jerry_value_t {{{name}}}_value = jerry_create_{{{Jerryscript_Type}}}(x.{{{name}}});
    {{/C_and_Jerryscript_Types}}
    jerry_set_property(new_jerry_value, {{{name}}}_prop_name, {{{name}}}_value);
    jerry_release_value({{{name}}}_value);
    jerry_release_value({{{name}}}_prop_name);
    {{/members}}

    return new_jerry_value;
    
} /* jerry_create_{{{name}}} */

{{/dictionaries}}


/* marshals the parameters for the function and then calls the
   function through the interpreter */
{{#callbacks}}
static {{#return_type}}{{{C_Type}}}{{/return_type}}
run_{{{name}}}_function(const jerry_value_t func_value,
{{{indentation}}}const jerry_value_t this_val{{^arguments.length}}){{/arguments.length}}{{#arguments.length}},{{/arguments.length}}
{{#arguments}}{{{indentation}}}{{#C_and_Jerryscript_Types}}{{{C_Type}}} {{{name}}}{{{separator}}}{{/C_and_Jerryscript_Types}}{{/arguments}}
{
{{#arguments}}{{#C_and_Jerryscript_Types}}
    jerry_value_t {{{name}}}_value = jerry_create_{{{Jerryscript_Type}}}({{{name}}});
{{/C_and_Jerryscript_Types}}{{/arguments}}

    jerry_value_t argv[] = { {{#arguments}}{{{name}}}_value{{^finalArgument}},{{/finalArgument}}{{/arguments}} };
    jerry_value_t jerry_return_value = jerry_call_function(func_value, this_val,
						           argv, {{{arguments.length}}});
	
    {{#return_type}}
    {{^voidReturnType}}
    return ({{{C_Type}}})jerry_get_{{{Jerryscript_Type}}}_value(jerry_return_value);
    {{/voidReturnType}}
    {{/return_type}}
} /* run_{{{name}}}_function */

{{/callbacks}}



{{#interfaces}}
{{#hasAttributes}}
/* attribute GETTERS */
{{#attributes}}
{{#C_and_Jerryscript_Types}}
{{^callback}}
static {{{C_Type}}} extract_{{{interfaceName}}}_{{{name}}} (jerry_value_t this_pointer)
{
    jerry_value_t property_pointer = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t attribute_pointer = jerry_get_property(this_pointer, property_pointer);
    {{{C_Type}}} return_value = ({{{C_Type}}})jerry_get_{{{Jerryscript_Type}}}_value(attribute_pointer);
    jerry_release_value(property_pointer);
    jerry_release_value(attribute_pointer);
    return return_value;
} /* extract_{{interfaceName}}_{{name}} */
{{/callback}}
{{! if the attribute is a callback, just return the jerry_value_t for it }}
{{#callback}}
static jerry_value_t extract_{{{interfaceName}}}_{{{name}}} (jerry_value_t this_pointer)
{
    jerry_value_t property_pointer = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t attribute_pointer = jerry_get_property(this_pointer, property_pointer);

    jerry_release_value(property_pointer);

    return attribute_pointer;    
} /* extract_{{interfaceName}}_{{name}} */
{{/callback}}
{{/C_and_Jerryscript_Types}}

{{/attributes}}

static {{{name}}} jerry_get_{{{name}}}_value(jerry_value_t value)
{
    jerry_value_t object_value = jerry_value_to_object(value);
    {{{name}}} return_struct;

    {{#attributes}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string((const jerry_char_t *) "{{{name}}}");
    jerry_value_t {{{name}}}_value = jerry_get_property(object_value, {{{name}}}_prop_name);
    {{#C_and_Jerryscript_Types}}
    {{^callback}}
    return_struct.{{{name}}} = ({{{C_Type}}})jerry_get_{{{Jerryscript_Type}}}_value({{{name}}}_value);
    {{/callback}}
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    jerry_release_value({{{name}}}_value);
//
    {{/attributes}}

    jerry_release_value(object_value);

    return return_struct;
} /* jerry_get_{{{name}}}_value */

static jerry_value_t jerry_create_{{{name}}}({{{name}}} x)
{
    jerry_value_t dummy_jerry_value;
    jerry_value_t new_jerry_value = create_{{{name}}}_interface_handler(
							dummy_jerry_value,
							dummy_jerry_value,
							&dummy_jerry_value,
							0);

    {{#attributes}}
    jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
    {{#C_and_Jerryscript_Types}}
    {{^callback}}
    jerry_value_t {{{name}}}_value = jerry_create_{{{Jerryscript_Type}}}(x.{{{name}}});
    jerry_set_property(new_jerry_value, {{{name}}}_prop_name, {{{name}}}_value);
    jerry_release_value({{{name}}}_value);
    {{/callback}}
    {{! TODO: if it's a callback, apply set_external_handler?}}
    {{/C_and_Jerryscript_Types}}
    jerry_release_value({{{name}}}_prop_name);
    {{/attributes}}

    return new_jerry_value;
    
} /* jerry_create_{{{name}}} */
{{/hasAttributes}}
{{/interfaces}}

// put all of the native-code functions (indentifable by the
// suffix "_handler") here:

{{#interfaces}}
    {{! set up #defs to get at attributes of the interface}}
    {{#attributes}}
    {{#C_and_Jerryscript_Types}}
    {{^callback}}
#define attribute_{{{name}}} (extract_{{{interfaceName}}}_{{{name}}}(this_val))
    {{/callback}}
    {{#callback}}
#define attribute_{{{name}}}(this_val, ...) (run_{{{C_Type}}}_function(extract_{{{interfaceName}}}_{{{name}}}(this_val), this_val, __VA_ARGS__))
    {{/callback}}
    {{/C_and_Jerryscript_Types}}
    {{/attributes}}
    {{#operations}}
static jerry_value_t
{{{name}}}_handler(const jerry_value_t func_value, /**< function object */
		   const jerry_value_t this_val, /**< this arg */
                   const jerry_value_t *args_p, /**< function arguments */
                   const jerry_length_t args_cnt) /**< number of function arguments */
{
    // demarshal the arguments
{{! TODO: the "this_val" passed in to a function parameter: should it be
    this_val, or should we gen up a value_t for the global object? }}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	{{#callback}}
#define {{{name}}}(...) (run_{{{C_Type}}}_function(args_p[{{{paramIndex}}}], this_val, __VA_ARGS__))
	{{/callback}}
	{{^callback}}
    {{C_Type}} {{{name}}} = jerry_get_{{{Jerryscript_Type}}}_value(args_p[{{{paramIndex}}}]);
	{{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}

//
    // set up by AugmentedAST.js
    {{#C_CODE_BODY}}
    {{{C_CODE_BODY}}}
    {{/C_CODE_BODY}}
    {{^C_CODE_BODY}}
    //
    // USER CODE GOES HERE
    //
    {{/C_CODE_BODY}}
//
    {{#C_and_Jerryscript_Types}}
    {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
    {{/voidReturnType}}
    {{^voidReturnType}}
    return jerry_create_{{{Jerryscript_Type}}}({{{C_CODE_RETURN_VALUE}}});
    {{/voidReturnType}}
    {{/C_and_Jerryscript_Types}}
    
} /* {{{name}}}_handler */
/*
 *
 */
    {{/operations}}
{{/interfaces}}


{{#hasOperations}}
static void register_function_call(jerry_value_t enclosing_object,
				   const char *function_name,
       			           jerry_external_handler_t handler)
{
  /* Create a JS function object and wrap into a jerry value */
  jerry_value_t function_object = jerry_create_external_function(handler);

  /* Set the native function as a property of the enclosing object
     (either the global object, or a user-define object) */
  jerry_value_t prop_name =
                 jerry_create_string((const jerry_char_t *) function_name);
  jerry_set_property(enclosing_object, prop_name, function_object);
  jerry_release_value(function_object);
  jerry_release_value(prop_name);
} /* register_function_call */
{{/hasOperations}}

// we define types here, and marshalling/demarshalling methods of each type.
static void load_types_into_Jerryscript_environment()
{
    static bool already_called = false;

    if (already_called) return;
    else already_called = true;

{{#dictionaries}}
    /* Create a JS object */
    const jerry_char_t my_js_object_{{{name}}}[] = " \
        function {{{name}}}({{#members}}{{{name}}}_parm{{^finalMember}},{{/finalMember}}{{/members}}) \
        { \
            {{#members}}
            this.{{{name}}} = {{{name}}}_parm; \
            {{/members}}
        }; \
      ";
    jerry_value_t my_js_obj_val_{{{name}}};

    /* Evaluate script */
    my_js_obj_val_{{{name}}} = jerry_eval (my_js_object_{{{name}}},
                              strlen ((const char *) my_js_object_{{{name}}}),
                              false);
    jerry_release_value(my_js_obj_val_{{{name}}});
{{/dictionaries}}
} /* load_types_into_Jerryscript_environment */


{{! we'll construct each interface object using Jerryscript commands
and then return the object instance thus created; so for each
interface: build the Jerryscript commands into a "handler" function,
and then enter the handler as a language extension with the
interface's name }}
{{! (...and only do this for non-global interfaces...) }}

{{#interfaces}}
{{#NoInterfaceObject}}
static jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt)
{
    jerry_value_t new_{{{interfaceName}}} = jerry_create_object();

    {{#attributes}}
    if ((((signed int)args_cnt)-1) >= {{{attribute_index}}})
    {
        jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
        jerry_set_property(new_{{{interfaceName}}}, {{{name}}}_prop_name, args_p[{{{attribute_index}}}]);
        jerry_release_value({{{name}}}_prop_name);
    }
    {{/attributes}}

    {{#operations}}
    register_function_call(new_{{{interfaceName}}}, "{{{name}}}", &{{{name}}}_handler);
    {{/operations}}

    return new_{{{interfaceName}}};
} /* create_{{{name}}}_interface_handler */
{{/NoInterfaceObject}}
{{/interfaces}}


{{#interfaces}}
void load_{{{name}}}_interface(void)
{
    load_types_into_Jerryscript_environment();

    {{! if the interface is not in the global namespace, then we'll
       need an object for the whole interface, and we'll need to
       register operations in that object rather than the global
       namespace }}
    {{! for attributes: attributes cannot get a default value, which
       means that they don't need to be created now; Javascript
       automagically creates them when they're first defined, so we
       don't need to do anything -- we probably don't need to do
       anything in the object version of the interface, either, but it
       looks nice... }}

    jerry_value_t global_object = jerry_get_global_object();
{{#NoInterfaceObject}}
    register_function_call(global_object, "{{{name}}}", &create_{{{name}}}_interface_handler);
{{/NoInterfaceObject}}
{{^NoInterfaceObject}}
    {{#operations}}
    register_function_call(global_object, "{{{name}}}", &{{{name}}}_handler);
    {{/operations}}
{{/NoInterfaceObject}}
    jerry_release_value(global_object);

} /* load_{{{name}}}_interface */
{{/interfaces}}

