{{! Mustache doesn't understand transfer blank lines from this script
    file to the output file unless those blank lines are within a
    #<name> construct, so we wrap this entire script with a name
    that shouldn't(!) be in the input file }}
{{^OBEYFORMATTING}}
/* AUTOMATICALLY GENERATED ON {{timestamp}} */

#include <stdio.h>
#include <stdlib.h>

#include "jerry-api.h"

// If the user has dictionary types, we'll do all of the #includes
// there, and we'll get them for free when we include the .h file for the
// dictionaries; but if they didn't add any dictionaries, we need to
// ensure that the .c file gets the necessary #includes
{{#hasDictTypes}}
#include "{{{moduleName}}}_Types.h"
{{/hasDictTypes}}
{{^hasDictTypes}}
{{#library_includes}}
#include <{{{name}}}>
{{/library_includes}}
{{#local_includes}}
#include "{{{name}}}"
{{/local_includes}}
{{/hasDictTypes}}

/*#include "jerry-port.h"*/
/*#include "jerry-port-default.h"*/

{{#interfaces}}
{{#NoInterfaceObject}}
jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt);
{{/NoInterfaceObject}}
{{/interfaces}}

// put all of the native-code functions (indentifable by the
// suffix "_handler") here:

{{#interfaces}}
    {{#operations}}
static jerry_value_t
{{{name}}}_handler(const jerry_value_t func_value, /**< function object */
		   const jerry_value_t this_val, /**< this arg */
                   const jerry_value_t *args_p, /**< function arguments */
                   const jerry_length_t args_cnt) /**< number of function arguments */
{
    // demarshal the arguments
{{! TODO: the "this_val" passed in to a function parameter: should it be
    this_val, or should we gen up a value_t for the global object? }}
    {{#arguments}}
        {{#variadic}}
   	     {{#C_and_Jerryscript_Types}}
    {{{C_Type}}}_Array {{{name}}} = jerry_get_array_of_{{{C_Type}}}(args_p, args_cnt, {{{paramIndex}}});
   	     {{/C_and_Jerryscript_Types}}
        {{/variadic}}
        {{^variadic}}
   	     {{#C_and_Jerryscript_Types}}
	     {{#callback}}
    {{{C_Type}}}_calling_context{{#is_array}}_Array{{/is_array}} {{{name}}} = ({{{C_Type}}}_calling_context){args_p[{{{paramIndex}}}], this_val};
	     {{/callback}}
	     {{^callback}}
    {{{C_Type}}}{{#is_array}}_Array{{/is_array}} {{{name}}} = jerry_get_{{^is_array}}{{{C_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}_value(args_p[{{{paramIndex}}}]);
	     {{/callback}}
             {{/C_and_Jerryscript_Types}}	
        {{/variadic}}
    {{/arguments}}

{{#repress_stubs}}
// USER CODE GOES HERE
{{/repress_stubs}}
{{^repress_stubs}}
{{#C_and_Jerryscript_Types}}
extern {{#return_is_this}}void{{/return_is_this}}{{^return_is_this}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{/return_is_this}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{#C_and_Jerryscript_Types}}{{{C_Type}}}{{#callback}}_calling_context{{/callback}}{{#is_array}}_Array{{/is_array}}{{/C_and_Jerryscript_Types}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#hasAttributes}}{{#arguments.length}}, {{/arguments.length}}jerry_value_t{{/hasAttributes}});

    {{^voidReturnType}}{{^return_is_this}}{{{C_Type}}}{{#is_array}}_Array{{/is_array}} return_value{{#is_string}}_string{{/is_string}} ={{/return_is_this}}{{/voidReturnType}} {{{interfaceName}}}_{{{name}}}_body({{#arguments}}{{{name}}}{{^finalParam}}, {{/finalParam}}{{/arguments}}{{#hasAttributes}}{{#arguments.length}}, {{/arguments.length}}this_val{{/hasAttributes}});
{{#is_string}}
    jerry_value_t return_value = jerry_create_string{{#is_array}}_Array{{/is_array}}({{^is_array}}(const jerry_char_t *){{/is_array}}return_value_string);
{{/is_string}}
{{/C_and_Jerryscript_Types}}

{{/repress_stubs}}
{{#repress_stubs}}
    {{! FREE MALLOC'D STRINGS}}
    {{#arguments}}
        {{#C_and_Jerryscript_Types}}
	    {{^callback}}
	        {{#is_string}}
		{{^is_array}}
    if ({{{name}}} != NULL) free({{{name}}});
		{{/is_array}}
       		{{/is_string}}
    	    {{/callback}}
        {{/C_and_Jerryscript_Types}}
    {{/arguments}}

{{/repress_stubs}}
{{^repress_stubs}}
    {{#C_and_Jerryscript_Types}}
        {{#return_is_this}}
    /* return a reference back to this interface */
    return this_val;
        {{/return_is_this}}
        {{^return_is_this}}
            {{#voidReturnType}}
    /* void return value */
    return jerry_create_undefined();
            {{/voidReturnType}}
            {{^voidReturnType}}
                {{^is_string}}
    return jerry_create_{{^is_array}}{{{Jerryscript_Type}}}{{/is_array}}{{#is_array}}{{{C_Type}}}_Array{{/is_array}}(return_value);
                {{/is_string}}
                {{#is_string}}
     return return_value;
                {{/is_string}}
            {{/voidReturnType}}
        {{/return_is_this}}
    {{/C_and_Jerryscript_Types}}

{{/repress_stubs}}
} /* {{{name}}}_handler */
/*
 *
 */
    {{/operations}}
{{/interfaces}}


// we define types here, and marshalling/demarshalling methods of each type.
static void load_types_into_Jerryscript_environment()
{
    static bool already_called = false;

    if (already_called) return;
    else already_called = true;

{{#dictionaries}}
    /* Create a JS object */
    const jerry_char_t my_js_object_{{{name}}}[] = " \
        function {{{name}}}({{#members}}{{{name}}}_parm{{^finalMember}},{{/finalMember}}{{/members}}) \
        { \
            {{#members}}
            this.{{{name}}} = {{{name}}}_parm; \
            {{/members}}
	    {{#C_type_list.length}}
	    this._what_kind_am_I = {{{name}}}; \ {{! name of object }}
	    {{/C_type_list.length}}
        }; \
      ";
    jerry_value_t my_js_obj_val_{{{name}}};

    /* Evaluate script */
    my_js_obj_val_{{{name}}} = jerry_eval (my_js_object_{{{name}}},
                              strlen ((const char *) my_js_object_{{{name}}}),
                              false);
    jerry_release_value(my_js_obj_val_{{{name}}});
{{/dictionaries}}
} /* load_types_into_Jerryscript_environment */


{{! (...and only do this for non-global interfaces...) -- TODO! }}

{{#interfaces}}
{{! #NoInterfaceObject}}
/* external declaration in {{{moduleName}}}_Types.h */
jerry_value_t
create_{{{name}}}_interface_handler(const jerry_value_t func_value,
		   const jerry_value_t this_val,
                   const jerry_value_t *args_p,
                   const jerry_length_t args_cnt)
{
    jerry_value_t new_{{{interfaceName}}} = jerry_create_object();

    {{#attributes}}
    if ((((signed int)args_cnt)-1) >= {{{attribute_index}}})
    {
        jerry_value_t {{{name}}}_prop_name = jerry_create_string ((const jerry_char_t *) "{{{name}}}");
        jerry_set_property(new_{{{interfaceName}}}, {{{name}}}_prop_name, args_p[{{{attribute_index}}}]);
        jerry_release_value({{{name}}}_prop_name);
    }
    {{/attributes}}

    jerry_value_t prototype = get_prototype((char *)"{{{interfaceName}}}");
    jerry_set_prototype(new_{{{interfaceName}}}, prototype);
    jerry_release_value(prototype);

    return new_{{{interfaceName}}};
} /* create_{{{name}}}_interface_handler */
{{! /NoInterfaceObject}}
{{/interfaces}}


{{#interfaces}}
void load_{{{name}}}_interface(void)
{
    load_types_into_Jerryscript_environment();

    {{! if the interface is not in the global namespace, then we'll
       need an object for the whole interface, and we'll need to
       register operations in that object rather than the global
       namespace }}
    {{! for attributes: attributes cannot get a default value, which
       means that they don't need to be created now; Javascript
       automagically creates them when they're first defined, so we
       don't need to do anything -- we probably don't need to do
       anything in the object version of the interface, either, but it
       looks nice... }}

    jerry_value_t global_object = jerry_get_global_object();
{{^NoInterfaceObject}}

    {{! TODO: in a concurrent environment, we could just check here to
       see if the prototype object is already populated (?) }}
    /* now, add all of the interface prototypes */
    jerry_value_t {{{name}}}_prototype_object = jerry_create_object();
    {{#operations}}
    register_function_call({{{interfaceName}}}_prototype_object,
                           "{{{name}}}", &{{{name}}}_handler);
    {{/operations}}
    set_prototype((char *)"{{{name}}}", {{{name}}}_prototype_object);
    jerry_release_value({{{name}}}_prototype_object);

    register_function_call(global_object, "{{{name}}}", &create_{{{name}}}_interface_handler);
{{/NoInterfaceObject}}
{{#NoInterfaceObject}}
    {{#operations}}
    register_function_call(global_object, "{{{interfaceName}}}_{{{name}}}", &{{{name}}}_handler);
    {{/operations}}
{{/NoInterfaceObject}}
    jerry_release_value(global_object);

} /* load_{{{name}}}_interface */
{{/interfaces}}

{{/OBEYFORMATTING}}
